{
  "overview": "# numwasm\n\n> NumPy-inspired n-dimensional array operations in TypeScript with WebAssembly acceleration.\n\nnumwasm provides a comprehensive NumPy-compatible API for n-dimensional arrays\nin TypeScript, with performance-critical operations compiled to WebAssembly.\n\n## Modules\n\n- [Linear Algebra](https://numwasm.quebi.de/docs/linalg): cholesky, cond, cross, det, dot, eig, eigh, eigvals, ...\n- [FFT](https://numwasm.quebi.de/docs/fft): fft, fft2, fftfreq, fftn, fftshift, hfft, ifft, ifft2, ...\n- [Random](https://numwasm.quebi.de/docs/random): BitGenerator, Generator, MT19937, PCG64, Philox, SeedSequence, SFC64, MT19937State, ...\n- [Masked Arrays](https://numwasm.quebi.de/docs/ma): allTrue, apply_along_axis, array, average, broadcast_mask, broadcast_mask_sync, clump_masked, clump_unmasked, ...\n- [Record Arrays](https://numwasm.quebi.de/docs/rec): array, find_duplicate, format_parser, fromarrays, fromfile, fromrecords, fromstring, IndexError, ...\n- [Strings](https://numwasm.quebi.de/docs/strings): add, capitalize, center, compare_chararrays, count, decode, encode, endswith, ...\n- [Polynomials](https://numwasm.quebi.de/docs/polynomial): ABCPolyBase, Chebyshev, Hermite, HermiteE, Laguerre, Legendre, PolyDomainWarning, PolyError, ...\n- [Testing](https://numwasm.quebi.de/docs/testing): AssertionError, KnownFailureException, SkipTest, assert_, assert_allclose, assert_almost_equal, assert_approx_equal, assert_array_almost_equal, ...\n\n## Core API\n\n- [Array Creation](https://numwasm.quebi.de/docs): NDArray, asarray, broadcastArrays, broadcastShapes, broadcastShapesMulti, broadcastTo, diag_indices, frombuffer, ...\n- [Array Manipulation](https://numwasm.quebi.de/docs): append, array_split, atleast_1d, atleast_2d, atleast_3d, block, choose, column_stack, ...\n- [Indexing](https://numwasm.quebi.de/docs): Slice, argwhere, buildIndexSpecs, expandEllipsis, flatnonzero, ndenumerate, ndindex, nditer, ...\n- [Math](https://numwasm.quebi.de/docs): abs, absolute, add, arccos, arccosh, arcsin, arcsinh, arctan, ...\n- [Logic](https://numwasm.quebi.de/docs): all, any, logical_and, logical_not, logical_or, logical_xor, piecewise, where\n- [Comparison](https://numwasm.quebi.de/docs): allclose, array_equal, array_equiv, equal, greater, greater_equal, isclose, iscomplex, ...\n- [Statistics](https://numwasm.quebi.de/docs): bincount, cumprod, cumsum, digitize, histogram, histogram_bin_edges, histogram2d, histogramdd, ...\n- [Sorting & Searching](https://numwasm.quebi.de/docs): argmax, argmin, argpartition, argsort, countNonzero, partition, searchsorted, sort\n- [Set Operations](https://numwasm.quebi.de/docs): in1d, intersect1d, isin, setdiff1d, setxor1d, union1d\n- [Bitwise](https://numwasm.quebi.de/docs): bitwise_and, bitwise_count, bitwise_not, bitwise_or, bitwise_xor, invert, left_shift, right_shift\n- [I/O](https://numwasm.quebi.de/docs): array2string, arrayRepr, arrayStr, baseRepr, baseReprArray, binaryRepr, binaryReprArray, formatFloatPositional, ...\n- [Window Functions](https://numwasm.quebi.de/docs): bartlett, blackman, hamming, hanning, kaiser\n- [Types & Interfaces](https://numwasm.quebi.de/docs): CastingKind, DType, Complex, Ediff1dOptions, EigResult, FieldDescriptor, FrombufferOptions, FromfileOptions, ...\n- [Constants](https://numwasm.quebi.de/docs): e, ellipsis, euler_gamma, inf, nan, NAN, newaxis, NINF, ...\n\n## Links\n\n- [Documentation](https://numwasm.quebi.de/docs)\n- [Benchmarks](https://numwasm.quebi.de/benchmarks)\n- [Full API Reference](https://numwasm.quebi.de/llms-full.txt)\n",
  "sections": [
    {
      "name": "cholesky",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.cholesky(a: NDArray, upper: boolean): Promise<NDArray>",
      "description": "Cholesky decomposition.  Returns the Cholesky factor of a Hermitian positive-definite matrix.",
      "content": "### cholesky\n\n`linalg.cholesky(a: NDArray, upper: boolean): Promise<NDArray>`\n\nCholesky decomposition.  Returns the Cholesky factor of a Hermitian positive-definite matrix.\n\n**Parameters:**\n- `a` (NDArray) — Hermitian positive-definite matrix (N x N)\n- `upper` (boolean) — If true, return upper triangular U (a = U^H @ U),\n               otherwise return lower triangular L (a = L @ L^H)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "cond",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.cond(x: NDArray, p: null | number): Promise<number>",
      "description": "Compute the condition number of a matrix.",
      "content": "### cond\n\n`linalg.cond(x: NDArray, p: null | number): Promise<number>`\n\nCompute the condition number of a matrix.\n\n**Parameters:**\n- `x` (NDArray) — Matrix\n- `p` (null | number) — Norm order (default: 2, using SVD)\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "cross",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.cross(a: NDArray, b: NDArray, axisa: number, axisb: number, axisc: number, axis: null | number): Promise<NDArray>",
      "description": "Return the cross product of two (arrays of) vectors.  The cross product of a and b in R^3 is a vector perpendicular to both a and b. The vectors are defined by the last axis by default.",
      "content": "### cross\n\n`linalg.cross(a: NDArray, b: NDArray, axisa: number, axisb: number, axisc: number, axis: null | number): Promise<NDArray>`\n\nReturn the cross product of two (arrays of) vectors.  The cross product of a and b in R^3 is a vector perpendicular to both a and b. The vectors are defined by the last axis by default.\n\n**Parameters:**\n- `a` (NDArray) — First vector(s)\n- `b` (NDArray) — Second vector(s)\n- `axisa` (number) — Axis of a that defines the vector(s) (default: -1)\n- `axisb` (number) — Axis of b that defines the vector(s) (default: -1)\n- `axisc` (number) — Axis of c that contains the cross product vectors (default: -1)\n- `axis` (null | number) — If specified, overrides axisa, axisb, and axisc\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "det",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.det(a: NDArray): Promise<number>",
      "description": "Compute the determinant of an array.",
      "content": "### det\n\n`linalg.det(a: NDArray): Promise<number>`\n\nCompute the determinant of an array.\n\n**Parameters:**\n- `a` (NDArray) — Square matrix (N x N)\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "dot",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.dot(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Dot product of two arrays.  For 1-D arrays: inner product of vectors. For 2-D arrays: matrix multiplication.",
      "content": "### dot\n\n`linalg.dot(a: NDArray, b: NDArray): Promise<NDArray>`\n\nDot product of two arrays.  For 1-D arrays: inner product of vectors. For 2-D arrays: matrix multiplication.\n\n**Parameters:**\n- `a` (NDArray) — First array\n- `b` (NDArray) — Second array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "eig",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.eig(a: NDArray): Promise<EigResult>",
      "description": "Compute eigenvalues and right eigenvectors of a general matrix.",
      "content": "### eig\n\n`linalg.eig(a: NDArray): Promise<EigResult>`\n\nCompute eigenvalues and right eigenvectors of a general matrix.\n\n**Parameters:**\n- `a` (NDArray) — Square matrix (N x N)\n\n**Returns:** `Promise<EigResult>`\n"
    },
    {
      "name": "eigh",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.eigh(a: NDArray, _UPLO: \"L\" | \"U\"): Promise<EigResult>",
      "description": "Compute eigenvalues and eigenvectors of a Hermitian/symmetric matrix.  Eigenvalues are always real and returned in ascending order.",
      "content": "### eigh\n\n`linalg.eigh(a: NDArray, _UPLO: \"L\" | \"U\"): Promise<EigResult>`\n\nCompute eigenvalues and eigenvectors of a Hermitian/symmetric matrix.  Eigenvalues are always real and returned in ascending order.\n\n**Parameters:**\n- `a` (NDArray) — Hermitian/symmetric matrix (N x N)\n- `_UPLO` (\"L\" | \"U\")\n\n**Returns:** `Promise<EigResult>`\n"
    },
    {
      "name": "eigvals",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.eigvals(a: NDArray): Promise<NDArray>",
      "description": "Compute eigenvalues only.",
      "content": "### eigvals\n\n`linalg.eigvals(a: NDArray): Promise<NDArray>`\n\nCompute eigenvalues only.\n\n**Parameters:**\n- `a` (NDArray)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "eigvalsh",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.eigvalsh(a: NDArray, UPLO: \"L\" | \"U\"): Promise<NDArray>",
      "description": "Compute eigenvalues of a Hermitian/symmetric matrix.",
      "content": "### eigvalsh\n\n`linalg.eigvalsh(a: NDArray, UPLO: \"L\" | \"U\"): Promise<NDArray>`\n\nCompute eigenvalues of a Hermitian/symmetric matrix.\n\n**Parameters:**\n- `a` (NDArray)\n- `UPLO` (\"L\" | \"U\")\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "inner",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.inner(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Inner product of two arrays. For 1-D arrays: dot product. For N-D arrays: sum product over last axes.",
      "content": "### inner\n\n`linalg.inner(a: NDArray, b: NDArray): Promise<NDArray>`\n\nInner product of two arrays. For 1-D arrays: dot product. For N-D arrays: sum product over last axes.\n\n**Parameters:**\n- `a` (NDArray)\n- `b` (NDArray)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "inv",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.inv(a: NDArray): Promise<NDArray>",
      "description": "Compute the (multiplicative) inverse of a matrix.",
      "content": "### inv\n\n`linalg.inv(a: NDArray): Promise<NDArray>`\n\nCompute the (multiplicative) inverse of a matrix.\n\n**Parameters:**\n- `a` (NDArray) — Square matrix (N x N)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "kron",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.kron(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Kronecker product of two arrays.  Computes the Kronecker product, a composite array made of blocks of the second array scaled by the first.",
      "content": "### kron\n\n`linalg.kron(a: NDArray, b: NDArray): Promise<NDArray>`\n\nKronecker product of two arrays.  Computes the Kronecker product, a composite array made of blocks of the second array scaled by the first.\n\n**Parameters:**\n- `a` (NDArray) — First array\n- `b` (NDArray) — Second array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "LinAlgError",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.LinAlgError",
      "description": "",
      "content": "### LinAlgError\n\n`linalg.LinAlgError`\n"
    },
    {
      "name": "lstsq",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.lstsq(a: NDArray, b: NDArray, rcond: null | number): Promise<LstsqResult>",
      "description": "Return the least-squares solution to a linear matrix equation.  Computes the vector x that approximately solves the equation a @ x = b.",
      "content": "### lstsq\n\n`linalg.lstsq(a: NDArray, b: NDArray, rcond: null | number): Promise<LstsqResult>`\n\nReturn the least-squares solution to a linear matrix equation.  Computes the vector x that approximately solves the equation a @ x = b.\n\n**Parameters:**\n- `a` (NDArray) — Coefficient matrix (M x N)\n- `b` (NDArray) — Ordinate values (M,) or (M x K)\n- `rcond` (null | number) — Cutoff for small singular values\n\n**Returns:** `Promise<LstsqResult>`\n"
    },
    {
      "name": "matmul",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.matmul(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Matrix multiplication of two arrays.  For 2-D arrays: regular matrix multiplication. For N-D arrays: broadcast over batch dimensions, matmul on last two.",
      "content": "### matmul\n\n`linalg.matmul(a: NDArray, b: NDArray): Promise<NDArray>`\n\nMatrix multiplication of two arrays.  For 2-D arrays: regular matrix multiplication. For N-D arrays: broadcast over batch dimensions, matmul on last two.\n\n**Parameters:**\n- `a` (NDArray) — First array (..., M, K)\n- `b` (NDArray) — Second array (..., K, N)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "matrix_norm",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.matrix_norm(x: NDArray, ord: number | \"fro\" | \"nuc\", keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the matrix norm.",
      "content": "### matrix_norm\n\n`linalg.matrix_norm(x: NDArray, ord: number | \"fro\" | \"nuc\", keepdims: boolean): Promise<number | NDArray>`\n\nCompute the matrix norm.\n\n**Parameters:**\n- `x` (NDArray) — Input matrix (..., M, N)\n- `ord` (number | \"fro\" | \"nuc\") — Order of the norm ('fro', 'nuc', 1, 2, -1, -2, Infinity, -Infinity)\n- `keepdims` (boolean) — If true, axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "matrix_power",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.matrix_power(a: NDArray, n: number): Promise<NDArray>",
      "description": "Raise a square matrix to the (integer) power n.",
      "content": "### matrix_power\n\n`linalg.matrix_power(a: NDArray, n: number): Promise<NDArray>`\n\nRaise a square matrix to the (integer) power n.\n\n**Parameters:**\n- `a` (NDArray) — Square matrix\n- `n` (number) — Exponent (can be negative for inverse)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "matrix_rank",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.matrix_rank(A: NDArray, tol: null | number): Promise<number>",
      "description": "Return matrix rank using SVD method.",
      "content": "### matrix_rank\n\n`linalg.matrix_rank(A: NDArray, tol: null | number): Promise<number>`\n\nReturn matrix rank using SVD method.\n\n**Parameters:**\n- `A` (NDArray) — Matrix to determine rank of\n- `tol` (null | number) — Threshold for considering singular values as zero\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "multi_dot",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.multi_dot(arrays: NDArray[]): Promise<NDArray>",
      "description": "Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.  Uses dynamic programming to find the optimal parenthesization that minimizes the total number of scalar multiplications.",
      "content": "### multi_dot\n\n`linalg.multi_dot(arrays: NDArray[]): Promise<NDArray>`\n\nCompute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.  Uses dynamic programming to find the optimal parenthesization that minimizes the total number of scalar multiplications.\n\n**Parameters:**\n- `arrays` (NDArray[]) — List of arrays to multiply together\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "norm",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.norm(x: NDArray, ord: null | number | \"fro\" | \"nuc\"): Promise<number>",
      "description": "Matrix or vector norm.",
      "content": "### norm\n\n`linalg.norm(x: NDArray, ord: null | number | \"fro\" | \"nuc\"): Promise<number>`\n\nMatrix or vector norm.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n- `ord` (null | number | \"fro\" | \"nuc\") — Order of the norm (default: 2 for vectors, 'fro' for matrices)\n             Vector norms: 1, 2, inf, -inf, or any positive number\n             Matrix norms: 1, 2, inf, -inf, 'fro', 'nuc'\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "outer",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.outer(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Compute the outer product of two vectors.",
      "content": "### outer\n\n`linalg.outer(a: NDArray, b: NDArray): Promise<NDArray>`\n\nCompute the outer product of two vectors.\n\n**Parameters:**\n- `a` (NDArray)\n- `b` (NDArray)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "pinv",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.pinv(a: NDArray, rcond: number): Promise<NDArray>",
      "description": "Compute the (Moore-Penrose) pseudo-inverse of a matrix.",
      "content": "### pinv\n\n`linalg.pinv(a: NDArray, rcond: number): Promise<NDArray>`\n\nCompute the (Moore-Penrose) pseudo-inverse of a matrix.\n\n**Parameters:**\n- `a` (NDArray) — Matrix to pseudo-invert\n- `rcond` (number) — Cutoff for small singular values\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "qr",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.qr(a: NDArray): Promise<QRResult>",
      "description": "QR decomposition.  Factor the matrix a as qr, where q is orthonormal and r is upper-triangular.",
      "content": "### qr\n\n`linalg.qr(a: NDArray): Promise<QRResult>`\n\nQR decomposition.  Factor the matrix a as qr, where q is orthonormal and r is upper-triangular.\n\n**Parameters:**\n- `a` (NDArray) — Matrix to factor (M x N)\n\n**Returns:** `Promise<QRResult>`\n"
    },
    {
      "name": "slogdet",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.slogdet(a: NDArray): Promise<SlogdetResult>",
      "description": "Compute sign and (natural) logarithm of the determinant. More numerically stable than computing det directly for large matrices.",
      "content": "### slogdet\n\n`linalg.slogdet(a: NDArray): Promise<SlogdetResult>`\n\nCompute sign and (natural) logarithm of the determinant. More numerically stable than computing det directly for large matrices.\n\n**Parameters:**\n- `a` (NDArray)\n\n**Returns:** `Promise<SlogdetResult>`\n"
    },
    {
      "name": "solve",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.solve(a: NDArray, b: NDArray): Promise<NDArray>",
      "description": "Solve a linear matrix equation: a @ x = b",
      "content": "### solve\n\n`linalg.solve(a: NDArray, b: NDArray): Promise<NDArray>`\n\nSolve a linear matrix equation: a @ x = b\n\n**Parameters:**\n- `a` (NDArray) — Coefficient matrix (N x N)\n- `b` (NDArray) — Ordinate values (N,) or (N x NRHS)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "svd",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.svd(a: NDArray, fullMatrices: boolean): Promise<SVDResult>",
      "description": "Singular Value Decomposition.",
      "content": "### svd\n\n`linalg.svd(a: NDArray, fullMatrices: boolean): Promise<SVDResult>`\n\nSingular Value Decomposition.\n\n**Parameters:**\n- `a` (NDArray) — Matrix to decompose (M x N)\n- `fullMatrices` (boolean) — If true, U and Vh have full shapes (M x M) and (N x N)\n                       If false, shapes are reduced (M x K) and (K x N)\n\n**Returns:** `Promise<SVDResult>`\n"
    },
    {
      "name": "svdvals",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.svdvals(a: NDArray): Promise<NDArray>",
      "description": "Return singular values only.",
      "content": "### svdvals\n\n`linalg.svdvals(a: NDArray): Promise<NDArray>`\n\nReturn singular values only.\n\n**Parameters:**\n- `a` (NDArray)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "tensordot",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.tensordot(a: NDArray, b: NDArray, axes: number | [number[], number[]]): Promise<NDArray>",
      "description": "Compute tensor dot product along specified axes.  For tensors a and b, tensordot(a, b, axes) computes the sum of products over the specified axes.",
      "content": "### tensordot\n\n`linalg.tensordot(a: NDArray, b: NDArray, axes: number | [number[], number[]]): Promise<NDArray>`\n\nCompute tensor dot product along specified axes.  For tensors a and b, tensordot(a, b, axes) computes the sum of products over the specified axes.\n\n**Parameters:**\n- `a` (NDArray) — First tensor\n- `b` (NDArray) — Second tensor\n- `axes` (number | [number[], number[]]) — Axes to sum over:\n  - number N: last N axes of a with first N axes of b\n  - [axesA, axesB]: specific axes for each tensor\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "tensorinv",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.tensorinv(a: NDArray, ind: number): Promise<NDArray>",
      "description": "Compute the 'inverse' of an N-dimensional array.  The result is an inverse for a with respect to the tensordot operation tensordot(a, b, ind).",
      "content": "### tensorinv\n\n`linalg.tensorinv(a: NDArray, ind: number): Promise<NDArray>`\n\nCompute the 'inverse' of an N-dimensional array.  The result is an inverse for a with respect to the tensordot operation tensordot(a, b, ind).\n\n**Parameters:**\n- `a` (NDArray) — Tensor to pseudo-invert\n- `ind` (number) — Number of first indices that are involved in the inverse sum\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "tensorsolve",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.tensorsolve(a: NDArray, b: NDArray, axes: null | number[]): Promise<NDArray>",
      "description": "Solve the tensor equation a x = b for x.  It is assumed that all indices of x are summed over in the product, together with the rightmost indices of a.",
      "content": "### tensorsolve\n\n`linalg.tensorsolve(a: NDArray, b: NDArray, axes: null | number[]): Promise<NDArray>`\n\nSolve the tensor equation a x = b for x.  It is assumed that all indices of x are summed over in the product, together with the rightmost indices of a.\n\n**Parameters:**\n- `a` (NDArray) — Coefficient tensor\n- `b` (NDArray) — Right-hand side tensor\n- `axes` (null | number[]) — Axes in a to reorder to the right, for the solve\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "trace",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.trace(a: NDArray, offset: number, axis1: number, axis2: number): Promise<number>",
      "description": "Return the sum along diagonals of the array.",
      "content": "### trace\n\n`linalg.trace(a: NDArray, offset: number, axis1: number, axis2: number): Promise<number>`\n\nReturn the sum along diagonals of the array.\n\n**Parameters:**\n- `a` (NDArray)\n- `offset` (number)\n- `axis1` (number)\n- `axis2` (number)\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "vdot",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.vdot(a: NDArray, b: NDArray): Promise<number>",
      "description": "Compute the dot product of two vectors (flattened inputs). For complex arrays, the first argument is conjugated.",
      "content": "### vdot\n\n`linalg.vdot(a: NDArray, b: NDArray): Promise<number>`\n\nCompute the dot product of two vectors (flattened inputs). For complex arrays, the first argument is conjugated.\n\n**Parameters:**\n- `a` (NDArray)\n- `b` (NDArray)\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "vector_norm",
      "module": "linalg",
      "category": "Linear Algebra",
      "signature": "linalg.vector_norm(x: NDArray, ord: number, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the vector norm.",
      "content": "### vector_norm\n\n`linalg.vector_norm(x: NDArray, ord: number, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nCompute the vector norm.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n- `ord` (number) — Order of the norm (default: 2, Euclidean)\n- `axis` (null | number) — Axis along which to compute. null = flatten\n- `keepdims` (boolean) — If true, axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "fft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.fft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the one-dimensional discrete Fourier Transform.",
      "content": "### fft\n\n`fft.fft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the one-dimensional discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray) — Input array (can be complex or real)\n- `n` (null | number) — Length of the transformed axis. If n < a.shape[axis], input is truncated.\n           If n > a.shape[axis], input is zero-padded. Default: a.shape[axis]\n- `axis` (number) — Axis over which to compute the FFT. Default: -1 (last axis)\n- `norm` (FFTNorm) — Normalization mode: \"backward\", \"ortho\", or \"forward\"\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fft2",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.fft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray",
      "description": "Compute the 2-dimensional discrete Fourier Transform.",
      "content": "### fft2\n\n`fft.fft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray`\n\nCompute the 2-dimensional discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `s` (null | [number, number]) — Shape (length of each axis) of the output. Default: shape of a\n- `axes` ([number, number]) — Axes over which to compute the FFT. Default: (-2, -1)\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fftfreq",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.fftfreq(n: number, d: number): Promise<NDArray>",
      "description": "Return the Discrete Fourier Transform sample frequencies.  Returns an array of length n with the sample frequencies: f = [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)   if n is even f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd",
      "content": "### fftfreq\n\n`fft.fftfreq(n: number, d: number): Promise<NDArray>`\n\nReturn the Discrete Fourier Transform sample frequencies.  Returns an array of length n with the sample frequencies: f = [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)   if n is even f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd\n\n**Parameters:**\n- `n` (number) — Window length\n- `d` (number) — Sample spacing (default: 1.0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "fftn",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.fftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray",
      "description": "Compute the N-dimensional discrete Fourier Transform.",
      "content": "### fftn\n\n`fft.fftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray`\n\nCompute the N-dimensional discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `s` (null | number[]) — Shape of the output along transformed axes\n- `axes` (null | number[]) — Axes over which to compute the FFT. Default: all axes\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fftshift",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.fftshift(x: NDArray, axes: null | number | number[]): NDArray",
      "description": "Shift the zero-frequency component to the center of the spectrum.  This function swaps half-spaces for all axes listed (or all axes by default).",
      "content": "### fftshift\n\n`fft.fftshift(x: NDArray, axes: null | number | number[]): NDArray`\n\nShift the zero-frequency component to the center of the spectrum.  This function swaps half-spaces for all axes listed (or all axes by default).\n\n**Parameters:**\n- `x` (NDArray) — Input array\n- `axes` (null | number | number[]) — Axes over which to shift. Default: all axes\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "hfft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.hfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the FFT of a signal that has Hermitian symmetry (real spectrum).",
      "content": "### hfft\n\n`fft.hfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the FFT of a signal that has Hermitian symmetry (real spectrum).\n\n**Parameters:**\n- `a` (NDArray) — Input array with Hermitian symmetry\n- `n` (null | number) — Length of the transformed axis\n- `axis` (number) — Axis over which to compute the FFT. Default: -1\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ifft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.ifft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the one-dimensional inverse discrete Fourier Transform.",
      "content": "### ifft\n\n`fft.ifft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the one-dimensional inverse discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `n` (null | number) — Length of the transformed axis\n- `axis` (number) — Axis over which to compute the inverse FFT. Default: -1\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ifft2",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.ifft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray",
      "description": "Compute the 2-dimensional inverse discrete Fourier Transform.",
      "content": "### ifft2\n\n`fft.ifft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray`\n\nCompute the 2-dimensional inverse discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | [number, number])\n- `axes` ([number, number])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ifftn",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.ifftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray",
      "description": "Compute the N-dimensional inverse discrete Fourier Transform.",
      "content": "### ifftn\n\n`fft.ifftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray`\n\nCompute the N-dimensional inverse discrete Fourier Transform.\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | number[])\n- `axes` (null | number[])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ifftshift",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.ifftshift(x: NDArray, axes: null | number | number[]): NDArray",
      "description": "The inverse of fftshift.  Undoes the effect of fftshift.",
      "content": "### ifftshift\n\n`fft.ifftshift(x: NDArray, axes: null | number | number[]): NDArray`\n\nThe inverse of fftshift.  Undoes the effect of fftshift.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n- `axes` (null | number | number[]) — Axes over which to shift. Default: all axes\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ihfft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.ihfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the inverse FFT of a signal that has Hermitian symmetry.",
      "content": "### ihfft\n\n`fft.ihfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the inverse FFT of a signal that has Hermitian symmetry.\n\n**Parameters:**\n- `a` (NDArray) — Input array (real-valued)\n- `n` (null | number) — Length of the transformed axis\n- `axis` (number) — Axis over which to compute the inverse FFT. Default: -1\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "irfft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.irfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the inverse of the one-dimensional discrete Fourier Transform for real input.  This function computes the inverse of the one-dimensional n-point DFT of Hermitian-symmetric input (from rfft). The input should have shape (..., n//2 + 1).",
      "content": "### irfft\n\n`fft.irfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the inverse of the one-dimensional discrete Fourier Transform for real input.  This function computes the inverse of the one-dimensional n-point DFT of Hermitian-symmetric input (from rfft). The input should have shape (..., n//2 + 1).\n\n**Parameters:**\n- `a` (NDArray) — Input array (complex, Hermitian-symmetric)\n- `n` (null | number) — Length of the output. If n is not given, it is determined from the\n           input shape: n = 2 * (a.shape[axis] - 1)\n- `axis` (number) — Axis over which to compute the inverse FFT. Default: -1\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "irfft2",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.irfft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray",
      "description": "Compute the inverse of the 2-dimensional FFT of real input.",
      "content": "### irfft2\n\n`fft.irfft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray`\n\nCompute the inverse of the 2-dimensional FFT of real input.\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | [number, number])\n- `axes` ([number, number])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "irfftn",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.irfftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray",
      "description": "Compute the inverse of the N-dimensional FFT of real input.",
      "content": "### irfftn\n\n`fft.irfftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray`\n\nCompute the inverse of the N-dimensional FFT of real input.\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | number[])\n- `axes` (null | number[])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rfft",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.rfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray",
      "description": "Compute the one-dimensional discrete Fourier Transform for real input.  This function computes the one-dimensional n-point DFT of a real-valued array. The output is Hermitian-symmetric, so only the positive frequencies are returned: output has shape (..., n//2 + 1).",
      "content": "### rfft\n\n`fft.rfft(a: NDArray, n: null | number, axis: number, norm: FFTNorm): NDArray`\n\nCompute the one-dimensional discrete Fourier Transform for real input.  This function computes the one-dimensional n-point DFT of a real-valued array. The output is Hermitian-symmetric, so only the positive frequencies are returned: output has shape (..., n//2 + 1).\n\n**Parameters:**\n- `a` (NDArray) — Input array (real-valued)\n- `n` (null | number) — Number of points in the FFT. If n < a.shape[axis], input is truncated.\n           If n > a.shape[axis], input is zero-padded.\n- `axis` (number) — Axis over which to compute the FFT. Default: -1\n- `norm` (FFTNorm) — Normalization mode\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rfft2",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.rfft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray",
      "description": "Compute the 2-dimensional FFT of a real array.",
      "content": "### rfft2\n\n`fft.rfft2(a: NDArray, s: null | [number, number], axes: [number, number], norm: FFTNorm): NDArray`\n\nCompute the 2-dimensional FFT of a real array.\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | [number, number])\n- `axes` ([number, number])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rfftfreq",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.rfftfreq(n: number, d: number): Promise<NDArray>",
      "description": "Return the Discrete Fourier Transform sample frequencies for rfft.  Returns an array of length n//2 + 1 with the positive sample frequencies: f = [0, 1, ..., n//2] / (d*n)",
      "content": "### rfftfreq\n\n`fft.rfftfreq(n: number, d: number): Promise<NDArray>`\n\nReturn the Discrete Fourier Transform sample frequencies for rfft.  Returns an array of length n//2 + 1 with the positive sample frequencies: f = [0, 1, ..., n//2] / (d*n)\n\n**Parameters:**\n- `n` (number) — Window length\n- `d` (number) — Sample spacing (default: 1.0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "rfftn",
      "module": "fft",
      "category": "FFT",
      "signature": "fft.rfftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray",
      "description": "Compute the N-dimensional discrete Fourier Transform for real input.  The output has Hermitian symmetry along the last transformed axis. Output shape along the last axis: s[-1]//2 + 1",
      "content": "### rfftn\n\n`fft.rfftn(a: NDArray, s: null | number[], axes: null | number[], norm: FFTNorm): NDArray`\n\nCompute the N-dimensional discrete Fourier Transform for real input.  The output has Hermitian symmetry along the last transformed axis. Output shape along the last axis: s[-1]//2 + 1\n\n**Parameters:**\n- `a` (NDArray)\n- `s` (null | number[])\n- `axes` (null | number[])\n- `norm` (FFTNorm)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "BitGenerator",
      "module": "random",
      "category": "Random",
      "signature": "class BitGenerator",
      "description": "Abstract base class for all bit generators. BitGenerators provide the core random number generation.",
      "content": "### BitGenerator\n\n`class BitGenerator`\n\nAbstract base class for all bit generators. BitGenerators provide the core random number generation.\n\n**Methods:**\n- `dispose(): void` — Clean up WASM resources.\n- `getState(): object` — Get the current state as a serializable object.\n- `next_double(): number` — Generate a random double in [0, 1).\n- `next_uint32(): number` — Generate a random 32-bit unsigned integer.\n- `next_uint64(): bigint` — Generate a random 64-bit unsigned integer.\n- `setState(state: object): void` — Restore state from a serializable object.\n- `spawn(n_children: number): BitGenerator[]` — Create independent child BitGenerators.\n"
    },
    {
      "name": "Generator",
      "module": "random",
      "category": "Random",
      "signature": "class Generator",
      "description": "Generator - main interface for random number generation.  Provides methods for generating random samples from various probability distributions. Uses a BitGenerator (default: PCG64) for the underlying random bits.",
      "content": "### Generator\n\n`class Generator`\n\nGenerator - main interface for random number generation.  Provides methods for generating random samples from various probability distributions. Uses a BitGenerator (default: PCG64) for the underlying random bits.\n\n**Methods:**\n- `beta(a: number, b: number, size?: SizeType): number | NDArray` — Draw samples from a Beta distribution.\n- `binomial(n: number, p: number, size?: SizeType): number | NDArray` — Draw samples from a binomial distribution.\n- `bytes(length: number): Uint8Array` — Return random bytes.\n- `chisquare(df: number, size?: SizeType): number | NDArray` — Draw samples from a chi-square distribution.\n- `choice(a: number | NDArray | number[], size?: SizeType, replace: boolean, _p?: null | NDArray | number[], axis: number, _shuffle: boolean): Promise<number | NDArray>` — Generates a random sample from a given array.\n- `dispose(): void` — Clean up WASM resources.\n- `exponential(scale: number, size?: SizeType): number | NDArray` — Draw samples from an exponential distribution.\n- `f(dfnum: number, dfden: number, size?: SizeType): number | NDArray` — Draw samples from an F distribution.\n- `gamma(shape: number, scale: number, size?: SizeType): number | NDArray` — Draw samples from a Gamma distribution.\n- `geometric(p: number, size?: SizeType): number | NDArray` — Draw samples from a geometric distribution.\n- `hypergeometric(ngood: number, nbad: number, nsample: number, size?: SizeType): number | NDArray` — Draw samples from a hypergeometric distribution.\n- `integers(low: number, high?: null | number, size?: SizeType, _dtype: DType, endpoint: boolean): number | NDArray` — Return random integers from low (inclusive) to high (exclusive).\n- `laplace(loc: number, scale: number, size?: SizeType): number | NDArray` — Draw samples from a Laplace (double exponential) distribution.\n- `lognormal(mean: number, sigma: number, size?: SizeType): number | NDArray` — Draw samples from a log-normal distribution.\n- `negative_binomial(n: number, p: number, size?: SizeType): number | NDArray` — Draw samples from a negative binomial distribution.\n- `normal(loc: number, scale: number, size?: SizeType): number | NDArray` — Draw random samples from a normal (Gaussian) distribution.\n- `pareto(a: number, size?: SizeType): number | NDArray` — Draw samples from a Pareto II (Lomax) distribution.\n- `permutation(x: number | NDArray, axis: number): Promise<NDArray>` — Randomly permute a sequence, or return a permuted range.\n- `poisson(lam: number, size?: SizeType): number | NDArray` — Draw samples from a Poisson distribution.\n- `random(size?: SizeType, dtype: DType): number | NDArray` — Return random floats in the half-open interval [0.0, 1.0).\n- `rayleigh(scale: number, size?: SizeType): number | NDArray` — Draw samples from a Rayleigh distribution.\n- `shuffle(x: NDArray, axis: number): Promise<void>` — Randomly shuffle elements along an axis. Modifies the array in-place.\n- `spawn(nChildren: number): Generator[]` — Spawn n_children independent Generators.  Each child generator uses an independent BitGenerator and produces statistically independent streams.\n- `standard_cauchy(size?: SizeType): number | NDArray` — Draw samples from a standard Cauchy distribution.\n- `standard_exponential(size?: SizeType, dtype: DType, method: \"zig\" | \"inv\"): number | NDArray` — Draw samples from a standard exponential distribution.\n- `standard_gamma(shape: number, size?: SizeType, dtype: DType): number | NDArray` — Draw samples from a standard Gamma distribution.\n- `standard_normal(size?: SizeType, dtype: DType): number | NDArray` — Draw samples from a standard Normal distribution (mean=0, stdev=1).\n- `standard_t(df: number, size?: SizeType): number | NDArray` — Draw samples from a Student's t distribution.\n- `uniform(low: number, high: number, size?: SizeType): number | NDArray` — Draw samples from a uniform distribution.\n- `weibull(a: number, size?: SizeType): number | NDArray` — Draw samples from a Weibull distribution.\n"
    },
    {
      "name": "MT19937",
      "module": "random",
      "category": "Random",
      "signature": "class MT19937",
      "description": "MT19937 BitGenerator - Classic Mersenne Twister.  Uses a 624 × 32-bit state array. Period is 2^19937 - 1. While historically popular, PCG64 or SFC64 are recommended for new applications.",
      "content": "### MT19937\n\n`class MT19937`\n\nMT19937 BitGenerator - Classic Mersenne Twister.  Uses a 624 × 32-bit state array. Period is 2^19937 - 1. While historically popular, PCG64 or SFC64 are recommended for new applications.\n\n**Methods:**\n- `dispose(): void` — Clean up WASM resources.\n- `getState(): MT19937State` — Get the current state as a serializable object.\n- `next_double(): number` — Generate a random double in [0, 1).\n- `next_uint32(): number` — Generate a random 32-bit unsigned integer.\n- `next_uint64(): bigint` — Generate a random 64-bit unsigned integer.\n- `setState(state: object): void` — Restore state from a serializable object.\n- `spawn(nChildren: number): MT19937[]` — Create independent child BitGenerators.\n"
    },
    {
      "name": "PCG64",
      "module": "random",
      "category": "Random",
      "signature": "class PCG64",
      "description": "PCG64 BitGenerator - the default for NumJS.  Uses a 128-bit LCG with XSL-RR output function. Provides a period of 2^128 and excellent statistical properties.",
      "content": "### PCG64\n\n`class PCG64`\n\nPCG64 BitGenerator - the default for NumJS.  Uses a 128-bit LCG with XSL-RR output function. Provides a period of 2^128 and excellent statistical properties.\n\n**Methods:**\n- `advance(delta: bigint): this` — Advance the state by delta steps.  This is equivalent to calling next_uint64() delta times, but runs in O(log(delta)) time.\n- `dispose(): void` — Clean up WASM resources.\n- `getState(): PCG64State` — Get the current state as a serializable object.\n- `jumped(jumps: number): PCG64` — Return a jumped copy of the generator.  The jumped generator is advanced by a large number of steps, providing an independent stream.\n- `next_double(): number` — Generate a random double in [0, 1).\n- `next_uint32(): number` — Generate a random 32-bit unsigned integer.\n- `next_uint64(): bigint` — Generate a random 64-bit unsigned integer.\n- `setState(state: object): void` — Restore state from a serializable object.\n- `spawn(nChildren: number): PCG64[]` — Create independent child BitGenerators.\n"
    },
    {
      "name": "Philox",
      "module": "random",
      "category": "Random",
      "signature": "class Philox",
      "description": "Philox BitGenerator - Counter-based RNG (Philox4x64-10).  Uses a 4 × 64-bit counter and 2 × 64-bit key. Supports efficient jump and advance operations. Well-suited for parallel and GPU applications.",
      "content": "### Philox\n\n`class Philox`\n\nPhilox BitGenerator - Counter-based RNG (Philox4x64-10).  Uses a 4 × 64-bit counter and 2 × 64-bit key. Supports efficient jump and advance operations. Well-suited for parallel and GPU applications.\n\n**Methods:**\n- `advance(delta: bigint): this` — Advance the generator by delta steps.\n- `dispose(): void` — Clean up WASM resources.\n- `getState(): PhiloxState` — Get the current state as a serializable object.\n- `jump(): this` — Jump ahead by 2^128 draws.  This is useful for creating independent streams without overlap.\n- `jumped(jumps: number): Philox` — Return a jumped copy of the generator.\n- `next_double(): number` — Generate a random double in [0, 1).\n- `next_uint32(): number` — Generate a random 32-bit unsigned integer.\n- `next_uint64(): bigint` — Generate a random 64-bit unsigned integer.\n- `setState(state: object): void` — Restore state from a serializable object.\n- `spawn(nChildren: number): Philox[]` — Create independent child BitGenerators.\n"
    },
    {
      "name": "SeedSequence",
      "module": "random",
      "category": "Random",
      "signature": "class SeedSequence",
      "description": "SeedSequence for reproducible entropy management.  Mixes entropy from multiple sources to generate high-quality seeds for any BitGenerator. Supports spawning for parallel streams.",
      "content": "### SeedSequence\n\n`class SeedSequence`\n\nSeedSequence for reproducible entropy management.  Mixes entropy from multiple sources to generate high-quality seeds for any BitGenerator. Supports spawning for parallel streams.\n\n**Methods:**\n- `generateState(nWords: number, dtype: \"uint32\" | \"uint64\"): Uint32Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>` — Generate state words for seeding a BitGenerator.\n- `spawn(nChildren: number): SeedSequence[]` — Spawn n_children independent SeedSequences.  Each child sequence is independent and can be used to seed a separate BitGenerator for parallel random streams.\n"
    },
    {
      "name": "SFC64",
      "module": "random",
      "category": "Random",
      "signature": "class SFC64",
      "description": "SFC64 BitGenerator - Small Fast Chaotic 64-bit generator.  Uses a 256-bit state (4 × 64-bit values). Fast with good statistical properties.",
      "content": "### SFC64\n\n`class SFC64`\n\nSFC64 BitGenerator - Small Fast Chaotic 64-bit generator.  Uses a 256-bit state (4 × 64-bit values). Fast with good statistical properties.\n\n**Methods:**\n- `dispose(): void` — Clean up WASM resources.\n- `getState(): SFC64State` — Get the current state as a serializable object.\n- `next_double(): number` — Generate a random double in [0, 1).\n- `next_uint32(): number` — Generate a random 32-bit unsigned integer.\n- `next_uint64(): bigint` — Generate a random 64-bit unsigned integer.\n- `setState(state: object): void` — Restore state from a serializable object.\n- `spawn(nChildren: number): SFC64[]` — Create independent child BitGenerators.\n"
    },
    {
      "name": "MT19937State",
      "module": "random",
      "category": "Random",
      "signature": "interface MT19937State",
      "description": "State object for MT19937 generator.",
      "content": "### MT19937State\n\n`interface MT19937State`\n\nState object for MT19937 generator.\n"
    },
    {
      "name": "PCG64State",
      "module": "random",
      "category": "Random",
      "signature": "interface PCG64State",
      "description": "State object for PCG64 generator.",
      "content": "### PCG64State\n\n`interface PCG64State`\n\nState object for PCG64 generator.\n"
    },
    {
      "name": "PhiloxState",
      "module": "random",
      "category": "Random",
      "signature": "interface PhiloxState",
      "description": "State object for Philox generator.",
      "content": "### PhiloxState\n\n`interface PhiloxState`\n\nState object for Philox generator.\n"
    },
    {
      "name": "SFC64State",
      "module": "random",
      "category": "Random",
      "signature": "interface SFC64State",
      "description": "State object for SFC64 generator.",
      "content": "### SFC64State\n\n`interface SFC64State`\n\nState object for SFC64 generator.\n"
    },
    {
      "name": "default_rng",
      "module": "random",
      "category": "Random",
      "signature": "random.default_rng(seed?: null | number | bigint | number[] | BitGenerator | SeedSequence, options?: object): Generator",
      "description": "Construct a new Generator with the given BitGenerator.  If seed is: - null/undefined: Use OS entropy - number/bigint: Create SeedSequence from the integer - array: Create SeedSequence from the array - SeedSequence: Use directly - BitGenerator: Use directly",
      "content": "### default_rng\n\n`random.default_rng(seed?: null | number | bigint | number[] | BitGenerator | SeedSequence, options?: object): Generator`\n\nConstruct a new Generator with the given BitGenerator.  If seed is: - null/undefined: Use OS entropy - number/bigint: Create SeedSequence from the integer - array: Create SeedSequence from the array - SeedSequence: Use directly - BitGenerator: Use directly\n\n**Parameters:**\n- `seed` (null | number | bigint | number[] | BitGenerator | SeedSequence) (optional) — Seed value or BitGenerator\n- `options` (object) (optional) — Options object with optional bitGenerator name\n\n**Returns:** `Generator`\n"
    },
    {
      "name": "getBitGenerator",
      "module": "random",
      "category": "Random",
      "signature": "random.getBitGenerator(name: string): object",
      "description": "Get a BitGenerator class by name.",
      "content": "### getBitGenerator\n\n`random.getBitGenerator(name: string): object`\n\nGet a BitGenerator class by name.\n\n**Parameters:**\n- `name` (string) — Name of the BitGenerator (case-insensitive)\n\n**Returns:** `object`\n"
    },
    {
      "name": "initRandom",
      "module": "random",
      "category": "Random",
      "signature": "random.initRandom(): Promise<void>",
      "description": "Initialize the random module.  This must be called before using any random functions. It loads the WASM module and sets up the default generator.",
      "content": "### initRandom\n\n`random.initRandom(): Promise<void>`\n\nInitialize the random module.  This must be called before using any random functions. It loads the WASM module and sets up the default generator.\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "listBitGenerators",
      "module": "random",
      "category": "Random",
      "signature": "random.listBitGenerators(): string[]",
      "description": "List available BitGenerator names.",
      "content": "### listBitGenerators\n\n`random.listBitGenerators(): string[]`\n\nList available BitGenerator names.\n\n**Returns:** `string[]`\n"
    },
    {
      "name": "randint",
      "module": "random",
      "category": "Random",
      "signature": "random.randint(low: number, high?: null | number, size?: SizeType): number | NDArray",
      "description": "Return random integers from low (inclusive) to high (exclusive).",
      "content": "### randint\n\n`random.randint(low: number, high?: null | number, size?: SizeType): number | NDArray`\n\nReturn random integers from low (inclusive) to high (exclusive).\n\n**Parameters:**\n- `low` (number) — Lower bound\n- `high` (null | number) (optional) — Upper bound (optional)\n- `size` (SizeType) (optional) — Output shape\n\n**Returns:** `number | NDArray`\n"
    },
    {
      "name": "randn",
      "module": "random",
      "category": "Random",
      "signature": "random.randn(...args: number[]): number | NDArray",
      "description": "Draw samples from a standard normal distribution.",
      "content": "### randn\n\n`random.randn(...args: number[]): number | NDArray`\n\nDraw samples from a standard normal distribution.\n\n**Parameters:**\n- `args` (number[]) (rest)\n\n**Returns:** `number | NDArray`\n"
    },
    {
      "name": "random",
      "module": "random",
      "category": "Random",
      "signature": "random.random(size?: SizeType): number | NDArray",
      "description": "Return random floats in the half-open interval [0.0, 1.0).",
      "content": "### random\n\n`random.random(size?: SizeType): number | NDArray`\n\nReturn random floats in the half-open interval [0.0, 1.0).\n\n**Parameters:**\n- `size` (SizeType) (optional) — Output shape\n\n**Returns:** `number | NDArray`\n"
    },
    {
      "name": "seed",
      "module": "random",
      "category": "Random",
      "signature": "random.seed(seed: number | bigint | number[]): void",
      "description": "Seed the default random generator.",
      "content": "### seed\n\n`random.seed(seed: number | bigint | number[]): void`\n\nSeed the default random generator.\n\n**Parameters:**\n- `seed` (number | bigint | number[]) — Seed value\n\n**Returns:** `void`\n"
    },
    {
      "name": "allTrue",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.allTrue(arr: NDArray): boolean",
      "description": "Check if all elements in a boolean array are true.",
      "content": "### allTrue\n\n`ma.allTrue(arr: NDArray): boolean`\n\nCheck if all elements in a boolean array are true.\n\n**Parameters:**\n- `arr` (NDArray)\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "apply_along_axis",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.apply_along_axis(func1d: object, axis: number, arr: MaskedArray): Promise<MaskedArray>",
      "description": "Apply a function along an axis to masked array.",
      "content": "### apply_along_axis\n\n`ma.apply_along_axis(func1d: object, axis: number, arr: MaskedArray): Promise<MaskedArray>`\n\nApply a function along an axis to masked array.\n\n**Parameters:**\n- `func1d` (object) — Function to apply (takes 1D array, returns scalar)\n- `axis` (number) — Axis along which to apply\n- `arr` (MaskedArray) — Input masked array\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "array",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.array(data: NDArray | number[] | MaskedArray, mask: boolean | MaskType | boolean[], dtype: DType, _copy: boolean, fill_value: null | number): Promise<MaskedArray>",
      "description": "Create a masked array (async).",
      "content": "### array\n\n`ma.array(data: NDArray | number[] | MaskedArray, mask: boolean | MaskType | boolean[], dtype: DType, _copy: boolean, fill_value: null | number): Promise<MaskedArray>`\n\nCreate a masked array (async).\n\n**Parameters:**\n- `data` (NDArray | number[] | MaskedArray) — Input data (array, NDArray, or MaskedArray)\n- `mask` (boolean | MaskType | boolean[]) — Boolean mask (true = masked)\n- `dtype` (DType) — Data type\n- `_copy` (boolean)\n- `fill_value` (null | number) — Fill value for masked elements\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "average",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.average(a: MaskedArray, axis: null | number, weights: null | NDArray | number[], returned: boolean): Promise<number | MaskedArray | [number | MaskedArray, number | MaskedArray]>",
      "description": "Weighted average along an axis.",
      "content": "### average\n\n`ma.average(a: MaskedArray, axis: null | number, weights: null | NDArray | number[], returned: boolean): Promise<number | MaskedArray | [number | MaskedArray, number | MaskedArray]>`\n\nWeighted average along an axis.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n- `axis` (null | number) — Axis along which to average (null for all elements)\n- `weights` (null | NDArray | number[]) — Weights for each element (default: equal weights)\n- `returned` (boolean) — If true, return tuple of (average, sum_of_weights)\n\n**Returns:** `Promise<number | MaskedArray | [number | MaskedArray, number | MaskedArray]>`\n"
    },
    {
      "name": "broadcast_mask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.broadcast_mask(mask: MaskType, targetShape: number[]): Promise<MaskType>",
      "description": "Broadcast a mask to a target shape (async version).",
      "content": "### broadcast_mask\n\n`ma.broadcast_mask(mask: MaskType, targetShape: number[]): Promise<MaskType>`\n\nBroadcast a mask to a target shape (async version).\n\n**Parameters:**\n- `mask` (MaskType) — Input mask\n- `targetShape` (number[]) — Shape to broadcast to\n\n**Returns:** `Promise<MaskType>`\n"
    },
    {
      "name": "broadcast_mask_sync",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.broadcast_mask_sync(mask: MaskType, targetShape: number[], result: NDArray): MaskType",
      "description": "Broadcast a mask to a target shape (sync version, result pre-allocated).",
      "content": "### broadcast_mask_sync\n\n`ma.broadcast_mask_sync(mask: MaskType, targetShape: number[], result: NDArray): MaskType`\n\nBroadcast a mask to a target shape (sync version, result pre-allocated).\n\n**Parameters:**\n- `mask` (MaskType)\n- `targetShape` (number[])\n- `result` (NDArray)\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "clump_masked",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.clump_masked(a: MaskedArray): SliceInfo[]",
      "description": "Find contiguous masked regions.",
      "content": "### clump_masked\n\n`ma.clump_masked(a: MaskedArray): SliceInfo[]`\n\nFind contiguous masked regions.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n\n**Returns:** `SliceInfo[]`\n"
    },
    {
      "name": "clump_unmasked",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.clump_unmasked(a: MaskedArray): SliceInfo[]",
      "description": "Find contiguous non-masked regions.",
      "content": "### clump_unmasked\n\n`ma.clump_unmasked(a: MaskedArray): SliceInfo[]`\n\nFind contiguous non-masked regions.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n\n**Returns:** `SliceInfo[]`\n"
    },
    {
      "name": "common_fill_value",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.common_fill_value(a: unknown, b: unknown): null | string | number | boolean",
      "description": "Find a common fill value for two masked arrays.  Returns the common fill value if both arrays have the same fill value, otherwise returns null.",
      "content": "### common_fill_value\n\n`ma.common_fill_value(a: unknown, b: unknown): null | string | number | boolean`\n\nFind a common fill value for two masked arrays.  Returns the common fill value if both arrays have the same fill value, otherwise returns null.\n\n**Parameters:**\n- `a` (unknown) — First array\n- `b` (unknown) — Second array\n\n**Returns:** `null | string | number | boolean`\n"
    },
    {
      "name": "corrcoef",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.corrcoef(x: MaskedArray, y: null | MaskedArray, rowvar: boolean): Promise<MaskedArray>",
      "description": "Compute correlation coefficients.",
      "content": "### corrcoef\n\n`ma.corrcoef(x: MaskedArray, y: null | MaskedArray, rowvar: boolean): Promise<MaskedArray>`\n\nCompute correlation coefficients.\n\n**Parameters:**\n- `x` (MaskedArray) — Input masked array (1D or 2D)\n- `y` (null | MaskedArray) — Optional second variable\n- `rowvar` (boolean) — If true, each row is a variable (default: true)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "cov",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.cov(x: MaskedArray, _y: null | MaskedArray, rowvar: boolean, ddof: number): Promise<MaskedArray>",
      "description": "Estimate covariance matrix.",
      "content": "### cov\n\n`ma.cov(x: MaskedArray, _y: null | MaskedArray, rowvar: boolean, ddof: number): Promise<MaskedArray>`\n\nEstimate covariance matrix.\n\n**Parameters:**\n- `x` (MaskedArray) — Input masked array (1D or 2D)\n- `_y` (null | MaskedArray)\n- `rowvar` (boolean) — If true, each row is a variable (default: true)\n- `ddof` (number) — Delta degrees of freedom (default: 1)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "default_fill_value",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.default_fill_value(obj: NDArray | DType | object): string | number | boolean",
      "description": "Get the default fill value for an object based on its dtype.",
      "content": "### default_fill_value\n\n`ma.default_fill_value(obj: NDArray | DType | object): string | number | boolean`\n\nGet the default fill value for an object based on its dtype.\n\n**Parameters:**\n- `obj` (NDArray | DType | object) — NDArray, MaskedArray, or dtype value\n\n**Returns:** `string | number | boolean`\n"
    },
    {
      "name": "defaultFillValues",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.defaultFillValues",
      "description": "",
      "content": "### defaultFillValues\n\n`ma.defaultFillValues`\n"
    },
    {
      "name": "empty",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.empty(shape: number | number[], dtype: DType): Promise<MaskedArray>",
      "description": "Create empty masked array.",
      "content": "### empty\n\n`ma.empty(shape: number | number[], dtype: DType): Promise<MaskedArray>`\n\nCreate empty masked array.\n\n**Parameters:**\n- `shape` (number | number[])\n- `dtype` (DType)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "empty_like",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.empty_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>",
      "description": "Create empty_like masked array.",
      "content": "### empty_like\n\n`ma.empty_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>`\n\nCreate empty_like masked array.\n\n**Parameters:**\n- `prototype` (NDArray | MaskedArray)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "flatnotmasked_contiguous",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.flatnotmasked_contiguous(a: MaskedArray): SliceInfo[]",
      "description": "Find contiguous non-masked regions in flattened array.",
      "content": "### flatnotmasked_contiguous\n\n`ma.flatnotmasked_contiguous(a: MaskedArray): SliceInfo[]`\n\nFind contiguous non-masked regions in flattened array.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n\n**Returns:** `SliceInfo[]`\n"
    },
    {
      "name": "flatnotmasked_edges",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.flatnotmasked_edges(a: MaskedArray): null | [number, number]",
      "description": "Find the flat indices of the first and last non-masked values.",
      "content": "### flatnotmasked_edges\n\n`ma.flatnotmasked_edges(a: MaskedArray): null | [number, number]`\n\nFind the flat indices of the first and last non-masked values.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n\n**Returns:** `null | [number, number]`\n"
    },
    {
      "name": "flatten_mask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.flatten_mask(mask: MaskType): MaskType",
      "description": "Flatten a mask to 1D.",
      "content": "### flatten_mask\n\n`ma.flatten_mask(mask: MaskType): MaskType`\n\nFlatten a mask to 1D.\n\n**Parameters:**\n- `mask` (MaskType) — Input mask\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "fromfunction",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.fromfunction(shape: number[], fn: object, dtype: DType): Promise<MaskedArray>",
      "description": "Create masked array from function.",
      "content": "### fromfunction\n\n`ma.fromfunction(shape: number[], fn: object, dtype: DType): Promise<MaskedArray>`\n\nCreate masked array from function.\n\n**Parameters:**\n- `shape` (number[])\n- `fn` (object)\n- `dtype` (DType)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "getdata",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.getdata(a: unknown): NDArray",
      "description": "Get the data from an array.",
      "content": "### getdata\n\n`ma.getdata(a: unknown): NDArray`\n\nGet the data from an array.\n\n**Parameters:**\n- `a` (unknown) — Input array (MaskedArray, NDArray, or other)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "getDefaultFillValue",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.getDefaultFillValue(dtype: DType): string | number | boolean",
      "description": "Get the default fill value for a dtype.",
      "content": "### getDefaultFillValue\n\n`ma.getDefaultFillValue(dtype: DType): string | number | boolean`\n\nGet the default fill value for a dtype.\n\n**Parameters:**\n- `dtype` (DType) — Data type\n\n**Returns:** `string | number | boolean`\n"
    },
    {
      "name": "getmask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.getmask(a: unknown): MaskType",
      "description": "Get the mask from an array.",
      "content": "### getmask\n\n`ma.getmask(a: unknown): MaskType`\n\nGet the mask from an array.\n\n**Parameters:**\n- `a` (unknown) — Input array (MaskedArray, NDArray, or other)\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "getmaskarray",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.getmaskarray(a: unknown): Promise<NDArray>",
      "description": "Get the mask from an array as an NDArray (never nomask).",
      "content": "### getmaskarray\n\n`ma.getmaskarray(a: unknown): Promise<NDArray>`\n\nGet the mask from an array as an NDArray (never nomask).\n\n**Parameters:**\n- `a` (unknown) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "getReductionFillValue",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.getReductionFillValue(dtype: DType, operation: \"sum\" | \"prod\" | \"min\" | \"max\"): number",
      "description": "Get the appropriate fill value for a reduction operation.",
      "content": "### getReductionFillValue\n\n`ma.getReductionFillValue(dtype: DType, operation: \"sum\" | \"prod\" | \"min\" | \"max\"): number`\n\nGet the appropriate fill value for a reduction operation.\n\n**Parameters:**\n- `dtype` (DType) — Data type\n- `operation` (\"sum\" | \"prod\" | \"min\" | \"max\") — Reduction operation ('sum', 'prod', 'min', 'max')\n\n**Returns:** `number`\n"
    },
    {
      "name": "is_mask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.is_mask(m: unknown): boolean",
      "description": "Check if an object is a valid mask.",
      "content": "### is_mask\n\n`ma.is_mask(m: unknown): boolean`\n\nCheck if an object is a valid mask.\n\n**Parameters:**\n- `m` (unknown) — Object to check\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "is_masked",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.is_masked(x: unknown): boolean",
      "description": "Check if an array has any masked elements.",
      "content": "### is_masked\n\n`ma.is_masked(x: unknown): boolean`\n\nCheck if an array has any masked elements.\n\n**Parameters:**\n- `x` (unknown) — Input to check\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "isMaskedConstant",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.isMaskedConstant(x: unknown): x",
      "description": "Check if a value is the masked constant.",
      "content": "### isMaskedConstant\n\n`ma.isMaskedConstant(x: unknown): x`\n\nCheck if a value is the masked constant.\n\n**Parameters:**\n- `x` (unknown) — Value to check\n\n**Returns:** `x`\n"
    },
    {
      "name": "make_mask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.make_mask(m: boolean | number[] | MaskType | boolean[], copy: boolean, shrink: boolean): Promise<MaskType>",
      "description": "Create a boolean mask from an array (async version).",
      "content": "### make_mask\n\n`ma.make_mask(m: boolean | number[] | MaskType | boolean[], copy: boolean, shrink: boolean): Promise<MaskType>`\n\nCreate a boolean mask from an array (async version).\n\n**Parameters:**\n- `m` (boolean | number[] | MaskType | boolean[]) — Input data (array, boolean, or mask)\n- `copy` (boolean) — If true, return a copy of the mask\n- `shrink` (boolean) — If true, return nomask if all values are False\n\n**Returns:** `Promise<MaskType>`\n"
    },
    {
      "name": "make_mask_none",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.make_mask_none(_shape: number[]): MaskType",
      "description": "Create a mask with all values False (no masking).",
      "content": "### make_mask_none\n\n`ma.make_mask_none(_shape: number[]): MaskType`\n\nCreate a mask with all values False (no masking).\n\n**Parameters:**\n- `_shape` (number[])\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "make_mask_sync",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.make_mask_sync(m: MaskType, copy: boolean, shrink: boolean): MaskType",
      "description": "Create a boolean mask from an array (sync version, requires existing NDArray). Use this when you already have an NDArray mask.",
      "content": "### make_mask_sync\n\n`ma.make_mask_sync(m: MaskType, copy: boolean, shrink: boolean): MaskType`\n\nCreate a boolean mask from an array (sync version, requires existing NDArray). Use this when you already have an NDArray mask.\n\n**Parameters:**\n- `m` (MaskType)\n- `copy` (boolean)\n- `shrink` (boolean)\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "mask_or",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.mask_or(m1: MaskType, m2: MaskType, shrink: boolean): Promise<MaskType>",
      "description": "Combine two masks with logical OR (async version).",
      "content": "### mask_or\n\n`ma.mask_or(m1: MaskType, m2: MaskType, shrink: boolean): Promise<MaskType>`\n\nCombine two masks with logical OR (async version).\n\n**Parameters:**\n- `m1` (MaskType) — First mask\n- `m2` (MaskType) — Second mask\n- `shrink` (boolean) — If true, return nomask if result is all False\n\n**Returns:** `Promise<MaskType>`\n"
    },
    {
      "name": "mask_or_sync",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.mask_or_sync(m1: MaskType, m2: MaskType, result: NDArray, shrink: boolean): MaskType",
      "description": "Combine two masks with logical OR (sync version for NDArray masks). Use when you already have NDArray masks and want sync behavior.",
      "content": "### mask_or_sync\n\n`ma.mask_or_sync(m1: MaskType, m2: MaskType, result: NDArray, shrink: boolean): MaskType`\n\nCombine two masks with logical OR (sync version for NDArray masks). Use when you already have NDArray masks and want sync behavior.\n\n**Parameters:**\n- `m1` (MaskType)\n- `m2` (MaskType)\n- `result` (NDArray)\n- `shrink` (boolean)\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "masked",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked",
      "description": "",
      "content": "### masked\n\n`ma.masked`\n"
    },
    {
      "name": "masked_all",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_all(shape: number | number[], dtype: DType): Promise<MaskedArray>",
      "description": "Create fully masked array.",
      "content": "### masked_all\n\n`ma.masked_all(shape: number | number[], dtype: DType): Promise<MaskedArray>`\n\nCreate fully masked array.\n\n**Parameters:**\n- `shape` (number | number[])\n- `dtype` (DType)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_all_like",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_all_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>",
      "description": "Create fully masked array like another.",
      "content": "### masked_all_like\n\n`ma.masked_all_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>`\n\nCreate fully masked array like another.\n\n**Parameters:**\n- `prototype` (NDArray | MaskedArray)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_array",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_array(data: NDArray | number[] | MaskedArray, mask: boolean | MaskType | boolean[], dtype: DType, _copy: boolean, fill_value: null | number): Promise<MaskedArray>",
      "description": "Create a masked array (async).",
      "content": "### masked_array\n\n`ma.masked_array(data: NDArray | number[] | MaskedArray, mask: boolean | MaskType | boolean[], dtype: DType, _copy: boolean, fill_value: null | number): Promise<MaskedArray>`\n\nCreate a masked array (async).\n\n**Parameters:**\n- `data` (NDArray | number[] | MaskedArray) — Input data (array, NDArray, or MaskedArray)\n- `mask` (boolean | MaskType | boolean[]) — Boolean mask (true = masked)\n- `dtype` (DType) — Data type\n- `_copy` (boolean)\n- `fill_value` (null | number) — Fill value for masked elements\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_equal",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_equal(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements equal to a value.",
      "content": "### masked_equal\n\n`ma.masked_equal(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements equal to a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_greater",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_greater(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements greater than a value.",
      "content": "### masked_greater\n\n`ma.masked_greater(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements greater than a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_greater_equal",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_greater_equal(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements greater than or equal to a value.",
      "content": "### masked_greater_equal\n\n`ma.masked_greater_equal(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements greater than or equal to a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_inside",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_inside(x: NDArray | number[], v1: number, v2: number): Promise<MaskedArray>",
      "description": "Mask elements inside an interval [v1, v2].",
      "content": "### masked_inside\n\n`ma.masked_inside(x: NDArray | number[], v1: number, v2: number): Promise<MaskedArray>`\n\nMask elements inside an interval [v1, v2].\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `v1` (number)\n- `v2` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_invalid",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_invalid(x: NDArray | number[]): Promise<MaskedArray>",
      "description": "Mask NaN and Inf values.",
      "content": "### masked_invalid\n\n`ma.masked_invalid(x: NDArray | number[]): Promise<MaskedArray>`\n\nMask NaN and Inf values.\n\n**Parameters:**\n- `x` (NDArray | number[])\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_less",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_less(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements less than a value.",
      "content": "### masked_less\n\n`ma.masked_less(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements less than a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_less_equal",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_less_equal(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements less than or equal to a value.",
      "content": "### masked_less_equal\n\n`ma.masked_less_equal(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements less than or equal to a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_not_equal",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_not_equal(x: NDArray | number[], value: number): Promise<MaskedArray>",
      "description": "Mask elements not equal to a value.",
      "content": "### masked_not_equal\n\n`ma.masked_not_equal(x: NDArray | number[], value: number): Promise<MaskedArray>`\n\nMask elements not equal to a value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_outside",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_outside(x: NDArray | number[], v1: number, v2: number): Promise<MaskedArray>",
      "description": "Mask elements outside an interval (v1, v2).",
      "content": "### masked_outside\n\n`ma.masked_outside(x: NDArray | number[], v1: number, v2: number): Promise<MaskedArray>`\n\nMask elements outside an interval (v1, v2).\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `v1` (number)\n- `v2` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_values",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_values(x: NDArray | number[], value: number, rtol: number, atol: number): Promise<MaskedArray>",
      "description": "Mask values close to a given value.",
      "content": "### masked_values\n\n`ma.masked_values(x: NDArray | number[], value: number, rtol: number, atol: number): Promise<MaskedArray>`\n\nMask values close to a given value.\n\n**Parameters:**\n- `x` (NDArray | number[])\n- `value` (number)\n- `rtol` (number)\n- `atol` (number)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "masked_where",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.masked_where(condition: NDArray | boolean[], x: NDArray | number[]): Promise<MaskedArray>",
      "description": "Mask elements where condition is true.",
      "content": "### masked_where\n\n`ma.masked_where(condition: NDArray | boolean[], x: NDArray | number[]): Promise<MaskedArray>`\n\nMask elements where condition is true.\n\n**Parameters:**\n- `condition` (NDArray | boolean[])\n- `x` (NDArray | number[])\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "MaskedArray",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.MaskedArray",
      "description": "",
      "content": "### MaskedArray\n\n`ma.MaskedArray`\n"
    },
    {
      "name": "MaskedArrayError",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.MaskedArrayError",
      "description": "",
      "content": "### MaskedArrayError\n\n`ma.MaskedArrayError`\n"
    },
    {
      "name": "MaskError",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.MaskError",
      "description": "",
      "content": "### MaskError\n\n`ma.MaskError`\n"
    },
    {
      "name": "maximumFillValue",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.maximumFillValue(dtype: DType): number",
      "description": "Maximum fill values for dtype (used for min operations). When computing min, masked values should be replaced with +Infinity so they don't affect the result.",
      "content": "### maximumFillValue\n\n`ma.maximumFillValue(dtype: DType): number`\n\nMaximum fill values for dtype (used for min operations). When computing min, masked values should be replaced with +Infinity so they don't affect the result.\n\n**Parameters:**\n- `dtype` (DType) — Data type\n\n**Returns:** `number`\n"
    },
    {
      "name": "median",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.median(a: MaskedArray, axis: null | number): number | MaskedArray",
      "description": "Compute the median along an axis.",
      "content": "### median\n\n`ma.median(a: MaskedArray, axis: null | number): number | MaskedArray`\n\nCompute the median along an axis.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n- `axis` (null | number) — Axis along which to compute median (null for all elements)\n\n**Returns:** `number | MaskedArray`\n"
    },
    {
      "name": "minimumFillValue",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.minimumFillValue(dtype: DType): number",
      "description": "Minimum fill values for dtype (used for max operations). When computing max, masked values should be replaced with -Infinity so they don't affect the result.",
      "content": "### minimumFillValue\n\n`ma.minimumFillValue(dtype: DType): number`\n\nMinimum fill values for dtype (used for max operations). When computing max, masked values should be replaced with -Infinity so they don't affect the result.\n\n**Parameters:**\n- `dtype` (DType) — Data type\n\n**Returns:** `number`\n"
    },
    {
      "name": "nomask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.nomask",
      "description": "",
      "content": "### nomask\n\n`ma.nomask`\n"
    },
    {
      "name": "notmasked_contiguous",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.notmasked_contiguous(a: MaskedArray, axis: null | number): SliceInfo[]",
      "description": "Find contiguous non-masked regions.",
      "content": "### notmasked_contiguous\n\n`ma.notmasked_contiguous(a: MaskedArray, axis: null | number): SliceInfo[]`\n\nFind contiguous non-masked regions.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n- `axis` (null | number) — Axis along which to search (null for flattened array)\n\n**Returns:** `SliceInfo[]`\n"
    },
    {
      "name": "notmasked_edges",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.notmasked_edges(a: MaskedArray, axis: null | number): null | [number, number]",
      "description": "Find the indices of the first and last non-masked values.",
      "content": "### notmasked_edges\n\n`ma.notmasked_edges(a: MaskedArray, axis: null | number): null | [number, number]`\n\nFind the indices of the first and last non-masked values.\n\n**Parameters:**\n- `a` (MaskedArray) — Input masked array\n- `axis` (null | number) — Axis along which to search (null for flattened array)\n\n**Returns:** `null | [number, number]`\n"
    },
    {
      "name": "ones",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.ones(shape: number | number[], dtype: DType): Promise<MaskedArray>",
      "description": "Create masked array of ones.",
      "content": "### ones\n\n`ma.ones(shape: number | number[], dtype: DType): Promise<MaskedArray>`\n\nCreate masked array of ones.\n\n**Parameters:**\n- `shape` (number | number[])\n- `dtype` (DType)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "ones_like",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.ones_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>",
      "description": "Create ones_like masked array.",
      "content": "### ones_like\n\n`ma.ones_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>`\n\nCreate ones_like masked array.\n\n**Parameters:**\n- `prototype` (NDArray | MaskedArray)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "reshape_mask",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.reshape_mask(mask: MaskType, shape: number[]): MaskType",
      "description": "Reshape a mask to a new shape.",
      "content": "### reshape_mask\n\n`ma.reshape_mask(mask: MaskType, shape: number[]): MaskType`\n\nReshape a mask to a new shape.\n\n**Parameters:**\n- `mask` (MaskType) — Input mask\n- `shape` (number[]) — New shape\n\n**Returns:** `MaskType`\n"
    },
    {
      "name": "set_fill_value",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.set_fill_value(a: unknown, fill_value: string | number | boolean): void",
      "description": "Set the fill value of a masked array.",
      "content": "### set_fill_value\n\n`ma.set_fill_value(a: unknown, fill_value: string | number | boolean): void`\n\nSet the fill value of a masked array.\n\n**Parameters:**\n- `a` (unknown) — MaskedArray to modify\n- `fill_value` (string | number | boolean) — New fill value\n\n**Returns:** `void`\n"
    },
    {
      "name": "zeros",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.zeros(shape: number | number[], dtype: DType): Promise<MaskedArray>",
      "description": "Create masked array of zeros.",
      "content": "### zeros\n\n`ma.zeros(shape: number | number[], dtype: DType): Promise<MaskedArray>`\n\nCreate masked array of zeros.\n\n**Parameters:**\n- `shape` (number | number[])\n- `dtype` (DType)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "zeros_like",
      "module": "ma",
      "category": "Masked Arrays",
      "signature": "ma.zeros_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>",
      "description": "Create zeros_like masked array.",
      "content": "### zeros_like\n\n`ma.zeros_like(prototype: NDArray | MaskedArray): Promise<MaskedArray>`\n\nCreate zeros_like masked array.\n\n**Parameters:**\n- `prototype` (NDArray | MaskedArray)\n\n**Returns:** `Promise<MaskedArray>`\n"
    },
    {
      "name": "array",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.array(data: null | NDArray | recarray | unknown[][], options: RecArrayOptions): Promise<recarray>",
      "description": "Create a record array.",
      "content": "### array\n\n`rec.array(data: null | NDArray | recarray | unknown[][], options: RecArrayOptions): Promise<recarray>`\n\nCreate a record array.\n\n**Parameters:**\n- `data` (null | NDArray | recarray | unknown[][]) — Input data (list of tuples, existing array, or null for empty)\n- `options` (RecArrayOptions) — Creation options\n\n**Returns:** `Promise<recarray>`\n"
    },
    {
      "name": "find_duplicate",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.find_duplicate(list: string[]): string[]",
      "description": "Find duplicate elements in a list.",
      "content": "### find_duplicate\n\n`rec.find_duplicate(list: string[]): string[]`\n\nFind duplicate elements in a list.\n\n**Parameters:**\n- `list` (string[]) — Array of strings to check\n\n**Returns:** `string[]`\n"
    },
    {
      "name": "format_parser",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.format_parser",
      "description": "",
      "content": "### format_parser\n\n`rec.format_parser`\n"
    },
    {
      "name": "fromarrays",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.fromarrays(arrayList: NDArray | number[] | string[][], options: RecArrayOptions): Promise<recarray>",
      "description": "Create a record array from a list of arrays (columns).",
      "content": "### fromarrays\n\n`rec.fromarrays(arrayList: NDArray | number[] | string[][], options: RecArrayOptions): Promise<recarray>`\n\nCreate a record array from a list of arrays (columns).\n\n**Parameters:**\n- `arrayList` (NDArray | number[] | string[][]) — List of arrays, one per field\n- `options` (RecArrayOptions) — Creation options\n\n**Returns:** `Promise<recarray>`\n"
    },
    {
      "name": "fromfile",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.fromfile(file: string | File, dtype: StructuredDType, shape: number[], offset: number): Promise<recarray>",
      "description": "Create a record array from a file.",
      "content": "### fromfile\n\n`rec.fromfile(file: string | File, dtype: StructuredDType, shape: number[], offset: number): Promise<recarray>`\n\nCreate a record array from a file.\n\n**Parameters:**\n- `file` (string | File) — File path (Node.js) or File object (browser)\n- `dtype` (StructuredDType) — Structured dtype\n- `shape` (number[]) — Shape of output array\n- `offset` (number) — Byte offset into file\n\n**Returns:** `Promise<recarray>`\n"
    },
    {
      "name": "fromrecords",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.fromrecords(recList: unknown[][], options: RecArrayOptions): Promise<recarray>",
      "description": "Create a record array from a list of records (rows).",
      "content": "### fromrecords\n\n`rec.fromrecords(recList: unknown[][], options: RecArrayOptions): Promise<recarray>`\n\nCreate a record array from a list of records (rows).\n\n**Parameters:**\n- `recList` (unknown[][]) — List of records (tuples or arrays)\n- `options` (RecArrayOptions) — Creation options\n\n**Returns:** `Promise<recarray>`\n"
    },
    {
      "name": "fromstring",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.fromstring(datastring: ArrayBuffer | Uint8Array<ArrayBufferLike>, dtype: StructuredDType, shape: number[], offset: number): Promise<recarray>",
      "description": "Create a record array from a binary string/buffer.",
      "content": "### fromstring\n\n`rec.fromstring(datastring: ArrayBuffer | Uint8Array<ArrayBufferLike>, dtype: StructuredDType, shape: number[], offset: number): Promise<recarray>`\n\nCreate a record array from a binary string/buffer.\n\n**Parameters:**\n- `datastring` (ArrayBuffer | Uint8Array<ArrayBufferLike>) — Binary data (ArrayBuffer or typed array)\n- `dtype` (StructuredDType) — Structured dtype\n- `shape` (number[]) — Shape of output array\n- `offset` (number) — Byte offset into data\n\n**Returns:** `Promise<recarray>`\n"
    },
    {
      "name": "IndexError",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.IndexError",
      "description": "",
      "content": "### IndexError\n\n`rec.IndexError`\n"
    },
    {
      "name": "KeyError",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.KeyError",
      "description": "",
      "content": "### KeyError\n\n`rec.KeyError`\n"
    },
    {
      "name": "recarray",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.recarray",
      "description": "",
      "content": "### recarray\n\n`rec.recarray`\n"
    },
    {
      "name": "record",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.record",
      "description": "",
      "content": "### record\n\n`rec.record`\n"
    },
    {
      "name": "ValueError",
      "module": "rec",
      "category": "Record Arrays",
      "signature": "rec.ValueError",
      "description": "",
      "content": "### ValueError\n\n`rec.ValueError`\n"
    },
    {
      "name": "add",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.add(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return element-wise string concatenation.",
      "content": "### add\n\n`strings.add(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn element-wise string concatenation.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "capitalize",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.capitalize(a: NDArray | string[]): NDArray",
      "description": "Return element-wise copy with first character capitalized and rest lowercase.",
      "content": "### capitalize\n\n`strings.capitalize(a: NDArray | string[]): NDArray`\n\nReturn element-wise copy with first character capitalized and rest lowercase.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "center",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.center(a: NDArray | string[], width: number, fillchar: string): NDArray",
      "description": "Return element-wise centered string of given width.",
      "content": "### center\n\n`strings.center(a: NDArray | string[], width: number, fillchar: string): NDArray`\n\nReturn element-wise centered string of given width.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `width` (number) — Total width of output string\n- `fillchar` (string) — Padding character (default space)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "compare_chararrays",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.compare_chararrays(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Compare two string arrays element-wise.",
      "content": "### compare_chararrays\n\n`strings.compare_chararrays(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nCompare two string arrays element-wise.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "count",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.count(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray",
      "description": "Return the number of non-overlapping occurrences of substring.",
      "content": "### count\n\n`strings.count(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray`\n\nReturn the number of non-overlapping occurrences of substring.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sub` (string) — Substring to count\n- `start` (number) — Start position for search (default 0)\n- `end` (null | number) — End position for search (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "decode",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.decode(a: Uint8Array<ArrayBufferLike>[], encoding: string): NDArray",
      "description": "Decode bytes to strings using specified encoding.",
      "content": "### decode\n\n`strings.decode(a: Uint8Array<ArrayBufferLike>[], encoding: string): NDArray`\n\nDecode bytes to strings using specified encoding.\n\n**Parameters:**\n- `a` (Uint8Array<ArrayBufferLike>[]) — Array of byte arrays (Uint8Arrays)\n- `encoding` (string) — Character encoding (default 'utf-8')\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "encode",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.encode(a: NDArray | string[], _encoding: string): Uint8Array<ArrayBufferLike>[]",
      "description": "Encode strings to bytes using specified encoding. Returns an array of Uint8Arrays (one per string element).",
      "content": "### encode\n\n`strings.encode(a: NDArray | string[], _encoding: string): Uint8Array<ArrayBufferLike>[]`\n\nEncode strings to bytes using specified encoding. Returns an array of Uint8Arrays (one per string element).\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `_encoding` (string)\n\n**Returns:** `Uint8Array<ArrayBufferLike>[]`\n"
    },
    {
      "name": "endswith",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.endswith(a: NDArray | string[], suffix: string, start: number, end: null | number): NDArray",
      "description": "Return true for each element if the string ends with suffix.",
      "content": "### endswith\n\n`strings.endswith(a: NDArray | string[], suffix: string, start: number, end: null | number): NDArray`\n\nReturn true for each element if the string ends with suffix.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `suffix` (string) — Suffix to check\n- `start` (number) — Start position (default 0)\n- `end` (null | number) — End position (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "equal",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 == x2) element-wise for string arrays.",
      "content": "### equal\n\n`strings.equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 == x2) element-wise for string arrays.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array or JS string array\n- `x2` (NDArray | string[]) — Second string array or JS string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "expandtabs",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.expandtabs(a: NDArray | string[], tabsize: number): NDArray",
      "description": "Return element-wise copy with tabs expanded to spaces.",
      "content": "### expandtabs\n\n`strings.expandtabs(a: NDArray | string[], tabsize: number): NDArray`\n\nReturn element-wise copy with tabs expanded to spaces.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `tabsize` (number) — Tab stop spacing (default 8)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "find",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.find(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray",
      "description": "For each element, return the lowest index where substring is found.",
      "content": "### find\n\n`strings.find(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray`\n\nFor each element, return the lowest index where substring is found.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sub` (string) — Substring to search for\n- `start` (number) — Start position for search (default 0)\n- `end` (null | number) — End position for search (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "greater",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.greater(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 > x2) element-wise for string arrays. Comparison is lexicographic.",
      "content": "### greater\n\n`strings.greater(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 > x2) element-wise for string arrays. Comparison is lexicographic.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "greater_equal",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.greater_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 >= x2) element-wise for string arrays. Comparison is lexicographic.",
      "content": "### greater_equal\n\n`strings.greater_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 >= x2) element-wise for string arrays. Comparison is lexicographic.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "index",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.index(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray",
      "description": "Like find, but raises ValueError if substring is not found.",
      "content": "### index\n\n`strings.index(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray`\n\nLike find, but raises ValueError if substring is not found.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sub` (string) — Substring to search for\n- `start` (number) — Start position for search (default 0)\n- `end` (null | number) — End position for search (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isalnum",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isalnum(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are alphanumeric.",
      "content": "### isalnum\n\n`strings.isalnum(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are alphanumeric.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isalpha",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isalpha(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are alphabetic.",
      "content": "### isalpha\n\n`strings.isalpha(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are alphabetic.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isdecimal",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isdecimal(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are decimal. Decimal characters are those in Unicode category \"Nd\".",
      "content": "### isdecimal\n\n`strings.isdecimal(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are decimal. Decimal characters are those in Unicode category \"Nd\".\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isdigit",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isdigit(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are digits (0-9).",
      "content": "### isdigit\n\n`strings.isdigit(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are digits (0-9).\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "islower",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.islower(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all cased characters are lowercase and there is at least one cased character.",
      "content": "### islower\n\n`strings.islower(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all cased characters are lowercase and there is at least one cased character.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isnumeric",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isnumeric(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are numeric. Numeric characters include digit characters and characters that have the Unicode numeric value property (subscripts, fractions, etc.).",
      "content": "### isnumeric\n\n`strings.isnumeric(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are numeric. Numeric characters include digit characters and characters that have the Unicode numeric value property (subscripts, fractions, etc.).\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isspace",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isspace(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all characters are whitespace.",
      "content": "### isspace\n\n`strings.isspace(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all characters are whitespace.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "istitle",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.istitle(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if the string is titlecased. A string is titlecased if uppercase characters follow uncased characters and lowercase characters follow cased characters.",
      "content": "### istitle\n\n`strings.istitle(a: NDArray | string[]): NDArray`\n\nReturn true for each element if the string is titlecased. A string is titlecased if uppercase characters follow uncased characters and lowercase characters follow cased characters.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isupper",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.isupper(a: NDArray | string[]): NDArray",
      "description": "Return true for each element if all cased characters are uppercase and there is at least one cased character.",
      "content": "### isupper\n\n`strings.isupper(a: NDArray | string[]): NDArray`\n\nReturn true for each element if all cased characters are uppercase and there is at least one cased character.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "less",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.less(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 < x2) element-wise for string arrays. Comparison is lexicographic (dictionary order).",
      "content": "### less\n\n`strings.less(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 < x2) element-wise for string arrays. Comparison is lexicographic (dictionary order).\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "less_equal",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.less_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 <= x2) element-wise for string arrays. Comparison is lexicographic.",
      "content": "### less_equal\n\n`strings.less_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 <= x2) element-wise for string arrays. Comparison is lexicographic.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ljust",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.ljust(a: NDArray | string[], width: number, fillchar: string): NDArray",
      "description": "Return element-wise left-justified string of given width.",
      "content": "### ljust\n\n`strings.ljust(a: NDArray | string[], width: number, fillchar: string): NDArray`\n\nReturn element-wise left-justified string of given width.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `width` (number) — Total width of output string\n- `fillchar` (string) — Padding character (default space)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "lower",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.lower(a: NDArray | string[]): NDArray",
      "description": "Return element-wise copy with uppercase characters converted to lowercase.",
      "content": "### lower\n\n`strings.lower(a: NDArray | string[]): NDArray`\n\nReturn element-wise copy with uppercase characters converted to lowercase.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "lstrip",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.lstrip(a: NDArray | string[], chars: null | string): NDArray",
      "description": "Return element-wise copy with leading characters removed.",
      "content": "### lstrip\n\n`strings.lstrip(a: NDArray | string[], chars: null | string): NDArray`\n\nReturn element-wise copy with leading characters removed.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `chars` (null | string) — Characters to remove (default: whitespace)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "multiply",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.multiply(a: NDArray | string[], i: number | number[]): NDArray",
      "description": "Return element-wise (a * i), string repeated i times.",
      "content": "### multiply\n\n`strings.multiply(a: NDArray | string[], i: number | number[]): NDArray`\n\nReturn element-wise (a * i), string repeated i times.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `i` (number | number[]) — Number of repetitions (or array of repetition counts)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "not_equal",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.not_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray",
      "description": "Return (x1 != x2) element-wise for string arrays.",
      "content": "### not_equal\n\n`strings.not_equal(x1: NDArray | string[], x2: NDArray | string[]): NDArray`\n\nReturn (x1 != x2) element-wise for string arrays.\n\n**Parameters:**\n- `x1` (NDArray | string[]) — First string array\n- `x2` (NDArray | string[]) — Second string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "partition",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.partition(a: NDArray | string[], sep: string): NDArray",
      "description": "Partition each element around the first occurrence of sep.",
      "content": "### partition\n\n`strings.partition(a: NDArray | string[], sep: string): NDArray`\n\nPartition each element around the first occurrence of sep.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sep` (string) — Separator string\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "replace",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.replace(a: NDArray | string[], old: string, new_: string, count: number): NDArray",
      "description": "Return element-wise copy with occurrences of old replaced by new.",
      "content": "### replace\n\n`strings.replace(a: NDArray | string[], old: string, new_: string, count: number): NDArray`\n\nReturn element-wise copy with occurrences of old replaced by new.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `old` (string) — Substring to replace\n- `new_` (string) — Replacement string\n- `count` (number) — Maximum replacements per element (-1 for all)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rfind",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.rfind(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray",
      "description": "For each element, return the highest index where substring is found.",
      "content": "### rfind\n\n`strings.rfind(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray`\n\nFor each element, return the highest index where substring is found.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sub` (string) — Substring to search for\n- `start` (number) — Start position for search (default 0)\n- `end` (null | number) — End position for search (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rindex",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.rindex(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray",
      "description": "Like rfind, but raises ValueError if substring is not found.",
      "content": "### rindex\n\n`strings.rindex(a: NDArray | string[], sub: string, start: number, end: null | number): NDArray`\n\nLike rfind, but raises ValueError if substring is not found.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sub` (string) — Substring to search for\n- `start` (number) — Start position for search (default 0)\n- `end` (null | number) — End position for search (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rjust",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.rjust(a: NDArray | string[], width: number, fillchar: string): NDArray",
      "description": "Return element-wise right-justified string of given width.",
      "content": "### rjust\n\n`strings.rjust(a: NDArray | string[], width: number, fillchar: string): NDArray`\n\nReturn element-wise right-justified string of given width.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `width` (number) — Total width of output string\n- `fillchar` (string) — Padding character (default space)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rpartition",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.rpartition(a: NDArray | string[], sep: string): NDArray",
      "description": "Partition each element around the last occurrence of sep.",
      "content": "### rpartition\n\n`strings.rpartition(a: NDArray | string[], sep: string): NDArray`\n\nPartition each element around the last occurrence of sep.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `sep` (string) — Separator string\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rstrip",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.rstrip(a: NDArray | string[], chars: null | string): NDArray",
      "description": "Return element-wise copy with trailing characters removed.",
      "content": "### rstrip\n\n`strings.rstrip(a: NDArray | string[], chars: null | string): NDArray`\n\nReturn element-wise copy with trailing characters removed.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `chars` (null | string) — Characters to remove (default: whitespace)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "startswith",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.startswith(a: NDArray | string[], prefix: string, start: number, end: null | number): NDArray",
      "description": "Return true for each element if the string starts with prefix.",
      "content": "### startswith\n\n`strings.startswith(a: NDArray | string[], prefix: string, start: number, end: null | number): NDArray`\n\nReturn true for each element if the string starts with prefix.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `prefix` (string) — Prefix to check\n- `start` (number) — Start position (default 0)\n- `end` (null | number) — End position (default string length)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "str_len",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.str_len(a: NDArray | string[]): NDArray",
      "description": "Return the length of each element.",
      "content": "### str_len\n\n`strings.str_len(a: NDArray | string[]): NDArray`\n\nReturn the length of each element.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "strip",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.strip(a: NDArray | string[], chars: null | string): NDArray",
      "description": "Return element-wise copy with leading and trailing characters removed.",
      "content": "### strip\n\n`strings.strip(a: NDArray | string[], chars: null | string): NDArray`\n\nReturn element-wise copy with leading and trailing characters removed.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `chars` (null | string) — Characters to remove (default: whitespace)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "swapcase",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.swapcase(a: NDArray | string[]): NDArray",
      "description": "Return element-wise copy with uppercase and lowercase swapped.",
      "content": "### swapcase\n\n`strings.swapcase(a: NDArray | string[]): NDArray`\n\nReturn element-wise copy with uppercase and lowercase swapped.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "title",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.title(a: NDArray | string[]): NDArray",
      "description": "Return element-wise titlecased version. Words start with uppercase, remaining characters are lowercase.",
      "content": "### title\n\n`strings.title(a: NDArray | string[]): NDArray`\n\nReturn element-wise titlecased version. Words start with uppercase, remaining characters are lowercase.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "upper",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.upper(a: NDArray | string[]): NDArray",
      "description": "Return element-wise copy with lowercase characters converted to uppercase.",
      "content": "### upper\n\n`strings.upper(a: NDArray | string[]): NDArray`\n\nReturn element-wise copy with lowercase characters converted to uppercase.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "zfill",
      "module": "strings",
      "category": "Strings",
      "signature": "strings.zfill(a: NDArray | string[], width: number): NDArray",
      "description": "Return element-wise numeric string left-padded with zeros. Sign prefix is handled correctly.",
      "content": "### zfill\n\n`strings.zfill(a: NDArray | string[], width: number): NDArray`\n\nReturn element-wise numeric string left-padded with zeros. Sign prefix is handled correctly.\n\n**Parameters:**\n- `a` (NDArray | string[]) — Input string array\n- `width` (number) — Total width of output string\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ABCPolyBase",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class ABCPolyBase",
      "description": "Abstract base class for polynomial series.  This class provides the common interface and operations for all polynomial types (Polynomial, Chebyshev, Legendre, etc.).  Subclasses must implement the static methods for basis-specific arithmetic.  Coefficients are stored in order of increasing degree, so: - `[1, 2, 3]` represents `1*P_0 + 2*P_1 + 3*P_2`  Where `P_n` is the nth basis polynomial (x^n for power series, T_n for Chebyshev, etc.)",
      "content": "### ABCPolyBase\n\n`class ABCPolyBase`\n\nAbstract base class for polynomial series.  This class provides the common interface and operations for all polynomial types (Polynomial, Chebyshev, Legendre, etc.).  Subclasses must implement the static methods for basis-specific arithmetic.  Coefficients are stored in order of increasing degree, so: - `[1, 2, 3]` represents `1*P_0 + 2*P_1 + 3*P_2`  Where `P_n` is the nth basis polynomial (x^n for power series, T_n for Chebyshev, etc.)\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [ABCPolyBase, ABCPolyBase]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "Chebyshev",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class Chebyshev",
      "description": "Chebyshev polynomial of the first kind.  Chebyshev polynomials are defined by: T_n(x) = cos(n * arccos(x))  Recurrence: T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x) with T_0(x) = 1, T_1(x) = x",
      "content": "### Chebyshev\n\n`class Chebyshev`\n\nChebyshev polynomial of the first kind.  Chebyshev polynomials are defined by: T_n(x) = cos(n * arccos(x))  Recurrence: T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x) with T_0(x) = 1, T_1(x) = x\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [Chebyshev, Chebyshev]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "Hermite",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class Hermite",
      "description": "Physicist's Hermite polynomial.  Hermite polynomials satisfy the recurrence: H_{n+1}(x) = 2*x*H_n(x) - 2*n*H_{n-1}(x)  with H_0(x) = 1, H_1(x) = 2x  These are orthogonal with weight exp(-x^2).",
      "content": "### Hermite\n\n`class Hermite`\n\nPhysicist's Hermite polynomial.  Hermite polynomials satisfy the recurrence: H_{n+1}(x) = 2*x*H_n(x) - 2*n*H_{n-1}(x)  with H_0(x) = 1, H_1(x) = 2x  These are orthogonal with weight exp(-x^2).\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [Hermite, Hermite]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "HermiteE",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class HermiteE",
      "description": "Probabilist's Hermite polynomial (HermiteE).  HermiteE polynomials satisfy the recurrence: He_{n+1}(x) = x*He_n(x) - n*He_{n-1}(x)  with He_0(x) = 1, He_1(x) = x  These are orthogonal with weight exp(-x^2/2).",
      "content": "### HermiteE\n\n`class HermiteE`\n\nProbabilist's Hermite polynomial (HermiteE).  HermiteE polynomials satisfy the recurrence: He_{n+1}(x) = x*He_n(x) - n*He_{n-1}(x)  with He_0(x) = 1, He_1(x) = x  These are orthogonal with weight exp(-x^2/2).\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [HermiteE, HermiteE]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "Laguerre",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class Laguerre",
      "description": "Laguerre polynomial.  Laguerre polynomials satisfy the recurrence: (n+1)*L_{n+1}(x) = (2n+1-x)*L_n(x) - n*L_{n-1}(x)  with L_0(x) = 1, L_1(x) = 1-x  These are orthogonal on [0, inf) with weight exp(-x).",
      "content": "### Laguerre\n\n`class Laguerre`\n\nLaguerre polynomial.  Laguerre polynomials satisfy the recurrence: (n+1)*L_{n+1}(x) = (2n+1-x)*L_n(x) - n*L_{n-1}(x)  with L_0(x) = 1, L_1(x) = 1-x  These are orthogonal on [0, inf) with weight exp(-x).\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [Laguerre, Laguerre]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "Legendre",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class Legendre",
      "description": "Legendre polynomial.  Legendre polynomials satisfy the recurrence: P_{n+1}(x) = ((2n+1)*x*P_n(x) - n*P_{n-1}(x)) / (n+1)  with P_0(x) = 1, P_1(x) = x",
      "content": "### Legendre\n\n`class Legendre`\n\nLegendre polynomial.  Legendre polynomials satisfy the recurrence: P_{n+1}(x) = ((2n+1)*x*P_n(x) - n*P_{n-1}(x)) / (n+1)  with P_0(x) = 1, P_1(x) = x\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [Legendre, Legendre]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "PolyDomainWarning",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class PolyDomainWarning",
      "description": "Warning class for polynomial domain issues.",
      "content": "### PolyDomainWarning\n\n`class PolyDomainWarning`\n\nWarning class for polynomial domain issues.\n"
    },
    {
      "name": "PolyError",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class PolyError",
      "description": "Error class for polynomial operations.",
      "content": "### PolyError\n\n`class PolyError`\n\nError class for polynomial operations.\n"
    },
    {
      "name": "Polynomial",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "class Polynomial",
      "description": "Power series polynomial.  Represents polynomials in the standard form: p(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n]*x^n",
      "content": "### Polynomial\n\n`class Polynomial`\n\nPower series polynomial.  Represents polynomials in the standard form: p(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n]*x^n\n\n**Properties:**\n- `basisName`: `string` — Name of the basis (for display)\n- `defaultDomain`: `[number, number]` — Default domain for this polynomial type\n- `defaultWindow`: `[number, number]` — Default window for this polynomial type\n\n**Methods:**\n- `add(other: number | ABCPolyBase): this` — Add another polynomial or scalar.\n- `call(x: number | NDArray | number[]): number | number[]` — Evaluate polynomial at x.  Maps x from domain to window before evaluation.\n- `copy(): this` — Create a copy.\n- `cutdeg(deg: number): this` — Truncate to maximum degree.\n- `deriv(m: number): this` — Differentiate polynomial m times.\n- `divmod(other: ABCPolyBase): [Polynomial, Polynomial]` — Divide by another polynomial.\n- `floordiv(other: ABCPolyBase): this` — Floor division (quotient only).\n- `hassamecoef(other: ABCPolyBase): boolean` — Check if same coefficients as other.\n- `hassamedomain(other: ABCPolyBase): boolean` — Check if same domain as other.\n- `hassametype(other: ABCPolyBase): boolean` — Check if same type as other.\n- `hassamewindow(other: ABCPolyBase): boolean` — Check if same window as other.\n- `integ(m: number, k: number[], lbnd: null | number): this` — Integrate polynomial m times.\n- `linspace(n: number): object` — Evaluate at n equally-spaced points in domain.\n- `mapparms(): [number, number]` — Get mapping parameters from domain to window.\n- `mod(other: ABCPolyBase): this` — Modulo (remainder only).\n- `mul(other: number | ABCPolyBase): this` — Multiply by another polynomial or scalar.\n- `neg(): this` — Negate polynomial.\n- `pow(n: number): this` — Raise to integer power.\n- `roots(): Promise<number[]>` — Find the roots of the polynomial.  Uses companion matrix eigenvalues via the linalg module.\n- `sub(other: number | ABCPolyBase): this` — Subtract another polynomial or scalar.\n- `toString(): string` — String representation.\n- `trim(tol: number): this` — Trim small trailing coefficients.\n- `truncate(size: number): this` — Truncate to number of coefficients.\n- `basis(this: object, deg: number, domain: null | [number, number], window: null | [number, number]): T` — Create a basis polynomial of given degree.  Returns a polynomial that is 1 in the specified basis element and 0 elsewhere.\n- `fit(this: object & object, x: NDArray | number[], y: NDArray | number[], deg: number, domain: null | [number, number], rcond: null | number, full: boolean, w: null | number[]): Promise<T | [T, object]>` — Least squares fit to data.\n- `fromroots(this: object, roots: number[], domain: null | [number, number], window: null | [number, number]): T` — Create polynomial from roots.\n- `identity(this: object, domain: null | [number, number], window: null | [number, number]): T` — Create identity polynomial p(x) = x.\n"
    },
    {
      "name": "maxpower",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.maxpower",
      "description": "Maximum allowed polynomial degree. Prevents excessive memory usage and computation time.",
      "content": "### maxpower\n\n`polynomial.maxpower`\n\nMaximum allowed polynomial degree. Prevents excessive memory usage and computation time.\n"
    },
    {
      "name": "as_series",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.as_series(alist: NDArray | number[][], trim: boolean): number[][]",
      "description": "Convert input to a list of 1D coefficient arrays.  This is used to normalize multiple coefficient array inputs for operations that work with several polynomials.",
      "content": "### as_series\n\n`polynomial.as_series(alist: NDArray | number[][], trim: boolean): number[][]`\n\nConvert input to a list of 1D coefficient arrays.  This is used to normalize multiple coefficient array inputs for operations that work with several polynomials.\n\n**Parameters:**\n- `alist` (NDArray | number[][]) — List of array-like coefficient sequences\n- `trim` (boolean) — If true, remove trailing zeros (default: true)\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "getdomain",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.getdomain(x: NDArray | number[]): [number, number]",
      "description": "Get the domain appropriate for given data points.  Returns the minimum and maximum of the data as the domain.",
      "content": "### getdomain\n\n`polynomial.getdomain(x: NDArray | number[]): [number, number]`\n\nGet the domain appropriate for given data points.  Returns the minimum and maximum of the data as the domain.\n\n**Parameters:**\n- `x` (NDArray | number[]) — Data points\n\n**Returns:** `[number, number]`\n"
    },
    {
      "name": "mapdomain",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.mapdomain(x: number | NDArray | number[], old: [number, number], new_: [number, number]): number | number[]",
      "description": "Map x from old domain to new domain.  The mapping is: new = off + scl * old where off and scl are computed from the domains.",
      "content": "### mapdomain\n\n`polynomial.mapdomain(x: number | NDArray | number[], old: [number, number], new_: [number, number]): number | number[]`\n\nMap x from old domain to new domain.  The mapping is: new = off + scl * old where off and scl are computed from the domains.\n\n**Parameters:**\n- `x` (number | NDArray | number[]) — Values to map (number, array, or NDArray)\n- `old` ([number, number]) — Original domain [min, max]\n- `new_` ([number, number]) — Target domain [min, max]\n\n**Returns:** `number | number[]`\n"
    },
    {
      "name": "mapparms",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.mapparms(old: [number, number], new_: [number, number]): [number, number]",
      "description": "Get linear mapping parameters between domains.  Returns [offset, scale] such that new = offset + scale * old",
      "content": "### mapparms\n\n`polynomial.mapparms(old: [number, number], new_: [number, number]): [number, number]`\n\nGet linear mapping parameters between domains.  Returns [offset, scale] such that new = offset + scale * old\n\n**Parameters:**\n- `old` ([number, number]) — Original domain [min, max]\n- `new_` ([number, number]) — Target domain [min, max]\n\n**Returns:** `[number, number]`\n"
    },
    {
      "name": "trimcoef",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.trimcoef(c: number[], tol: number): number[]",
      "description": "Remove small trailing coefficients.  Trailing elements with absolute value less than or equal to `tol` are removed.",
      "content": "### trimcoef\n\n`polynomial.trimcoef(c: number[], tol: number): number[]`\n\nRemove small trailing coefficients.  Trailing elements with absolute value less than or equal to `tol` are removed.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `tol` (number) — Tolerance for considering coefficients as zero (default: 0)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "trimseq",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.trimseq(seq: number[]): number[]",
      "description": "Remove trailing zeros from a sequence.",
      "content": "### trimseq\n\n`polynomial.trimseq(seq: number[]): number[]`\n\nRemove trailing zeros from a sequence.\n\n**Parameters:**\n- `seq` (number[]) — Input sequence\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "cheb2poly",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.cheb2poly(c: number[]): number[]",
      "description": "Convert Chebyshev coefficients to power series.",
      "content": "### cheb2poly\n\n`polynomial.cheb2poly(c: number[]): number[]`\n\nConvert Chebyshev coefficients to power series.\n\n**Parameters:**\n- `c` (number[]) — Chebyshev coefficients\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebadd(c1: number[], c2: number[]): number[]",
      "description": "Add two Chebyshev polynomials.",
      "content": "### chebadd\n\n`polynomial.chebadd(c1: number[], c2: number[]): number[]`\n\nAdd two Chebyshev polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebcompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebcompanion(c: number[]): number[][]",
      "description": "Generate Chebyshev companion matrix.",
      "content": "### chebcompanion\n\n`polynomial.chebcompanion(c: number[]): number[][]`\n\nGenerate Chebyshev companion matrix.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "chebder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebder(c: number[], m: number): number[]",
      "description": "Chebyshev derivative.",
      "content": "### chebder\n\n`polynomial.chebder(c: number[], m: number): number[]`\n\nChebyshev derivative.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `m` (number) — Number of derivatives (default: 1)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebdiv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebdiv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "Divide two Chebyshev polynomials.",
      "content": "### chebdiv\n\n`polynomial.chebdiv(c1: number[], c2: number[]): [number[], number[]]`\n\nDivide two Chebyshev polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "chebfit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "Chebyshev least squares fit.",
      "content": "### chebfit\n\n`polynomial.chebfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\nChebyshev least squares fit.\n\n**Parameters:**\n- `x` (number[]) — x values\n- `y` (number[]) — y values\n- `deg` (number) — Degree of fitting polynomial\n- `rcond` (null | number) — Cutoff for small singular values\n- `full` (boolean) — If true, return extra info\n- `w` (null | number[]) — Weights\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "chebfromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebfromroots(roots: number[]): number[]",
      "description": "Construct Chebyshev polynomial from roots.",
      "content": "### chebfromroots\n\n`polynomial.chebfromroots(roots: number[]): number[]`\n\nConstruct Chebyshev polynomial from roots.\n\n**Parameters:**\n- `roots` (number[]) — Array of roots\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "Chebyshev integral.",
      "content": "### chebint\n\n`polynomial.chebint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\nChebyshev integral.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `m` (number) — Number of integrals (default: 1)\n- `k` (number[]) — Integration constants (default: all zero)\n- `lbnd` (number) — Lower bound (default: 0)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebinterpolate",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebinterpolate(func: object, deg: number, domain: [number, number]): Promise<number[]>",
      "description": "Interpolate a function using Chebyshev polynomials.  Uses Chebyshev nodes for optimal interpolation on [-1, 1].",
      "content": "### chebinterpolate\n\n`polynomial.chebinterpolate(func: object, deg: number, domain: [number, number]): Promise<number[]>`\n\nInterpolate a function using Chebyshev polynomials.  Uses Chebyshev nodes for optimal interpolation on [-1, 1].\n\n**Parameters:**\n- `func` (object) — Function to interpolate\n- `deg` (number) — Degree of interpolating polynomial\n- `domain` ([number, number]) — Domain for interpolation (default: [-1, 1])\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "chebmul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebmul(c1: number[], c2: number[]): number[]",
      "description": "Multiply two Chebyshev polynomials.",
      "content": "### chebmul\n\n`polynomial.chebmul(c1: number[], c2: number[]): number[]`\n\nMultiply two Chebyshev polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebpow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebpow(c: number[], pow: number, maxpower: number): number[]",
      "description": "Raise Chebyshev polynomial to a power.",
      "content": "### chebpow\n\n`polynomial.chebpow(c: number[], pow: number, maxpower: number): number[]`\n\nRaise Chebyshev polynomial to a power.\n\n**Parameters:**\n- `c` (number[])\n- `pow` (number)\n- `maxpower` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebroots(c: number[]): Promise<number[]>",
      "description": "Find Chebyshev polynomial roots.",
      "content": "### chebroots\n\n`polynomial.chebroots(c: number[]): Promise<number[]>`\n\nFind Chebyshev polynomial roots.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "chebsub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebsub(c1: number[], c2: number[]): number[]",
      "description": "Subtract two Chebyshev polynomials.",
      "content": "### chebsub\n\n`polynomial.chebsub(c1: number[], c2: number[]): number[]`\n\nSubtract two Chebyshev polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebval(x: number, c: number[]): number",
      "description": "Evaluate Chebyshev polynomial using Clenshaw's algorithm.",
      "content": "### chebval\n\n`polynomial.chebval(x: number, c: number[]): number`\n\nEvaluate Chebyshev polynomial using Clenshaw's algorithm.\n\n**Parameters:**\n- `x` (number) — Point at which to evaluate\n- `c` (number[]) — Coefficient array [c0, c1, c2, ...] for c0*T_0 + c1*T_1 + c2*T_2 + ...\n\n**Returns:** `number`\n"
    },
    {
      "name": "chebval2d",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebval2d(x: number[], y: number[], c: number[][]): number[]",
      "description": "Evaluate 2D Chebyshev polynomial.",
      "content": "### chebval2d\n\n`polynomial.chebval2d(x: number[], y: number[], c: number[][]): number[]`\n\nEvaluate 2D Chebyshev polynomial.\n\n**Parameters:**\n- `x` (number[]) — x coordinates\n- `y` (number[]) — y coordinates\n- `c` (number[][]) — 2D coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "chebvander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.chebvander(x: number[], deg: number): number[][]",
      "description": "Chebyshev Vandermonde matrix.",
      "content": "### chebvander\n\n`polynomial.chebvander(x: number[], deg: number): number[][]`\n\nChebyshev Vandermonde matrix.\n\n**Parameters:**\n- `x` (number[]) — Sample points\n- `deg` (number) — Degree of polynomial\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "herm2poly",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.herm2poly(c: number[]): number[]",
      "description": "Convert Hermite coefficients to power series.",
      "content": "### herm2poly\n\n`polynomial.herm2poly(c: number[]): number[]`\n\nConvert Hermite coefficients to power series.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermadd(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermadd\n\n`polynomial.hermadd(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermcompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermcompanion(c: number[]): number[][]",
      "description": "",
      "content": "### hermcompanion\n\n`polynomial.hermcompanion(c: number[]): number[][]`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "hermder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermder(c: number[], m: number): number[]",
      "description": "",
      "content": "### hermder\n\n`polynomial.hermder(c: number[], m: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermdiv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermdiv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "",
      "content": "### hermdiv\n\n`polynomial.hermdiv(c1: number[], c2: number[]): [number[], number[]]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "herme2poly",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.herme2poly(c: number[]): number[]",
      "description": "Convert HermiteE coefficients to power series.",
      "content": "### herme2poly\n\n`polynomial.herme2poly(c: number[]): number[]`\n\nConvert HermiteE coefficients to power series.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermeadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermeadd(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermeadd\n\n`polynomial.hermeadd(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermecompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermecompanion(c: number[]): number[][]",
      "description": "",
      "content": "### hermecompanion\n\n`polynomial.hermecompanion(c: number[]): number[][]`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "hermeder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermeder(c: number[], m: number): number[]",
      "description": "",
      "content": "### hermeder\n\n`polynomial.hermeder(c: number[], m: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermediv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermediv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "",
      "content": "### hermediv\n\n`polynomial.hermediv(c1: number[], c2: number[]): [number[], number[]]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "hermefit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermefit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "",
      "content": "### hermefit\n\n`polynomial.hermefit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\n**Parameters:**\n- `x` (number[])\n- `y` (number[])\n- `deg` (number)\n- `rcond` (null | number)\n- `full` (boolean)\n- `w` (null | number[])\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "hermefromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermefromroots(roots: number[]): number[]",
      "description": "",
      "content": "### hermefromroots\n\n`polynomial.hermefromroots(roots: number[]): number[]`\n\n**Parameters:**\n- `roots` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermeint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermeint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "",
      "content": "### hermeint\n\n`polynomial.hermeint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n- `k` (number[])\n- `lbnd` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermemul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermemul(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermemul\n\n`polynomial.hermemul(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermepow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermepow(c: number[], pow: number, maxpower: number): number[]",
      "description": "",
      "content": "### hermepow\n\n`polynomial.hermepow(c: number[], pow: number, maxpower: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `pow` (number)\n- `maxpower` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermeroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermeroots(c: number[]): Promise<number[]>",
      "description": "",
      "content": "### hermeroots\n\n`polynomial.hermeroots(c: number[]): Promise<number[]>`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "hermesub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermesub(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermesub\n\n`polynomial.hermesub(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermeval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermeval(x: number, c: number[]): number",
      "description": "Evaluate HermiteE polynomial.",
      "content": "### hermeval\n\n`polynomial.hermeval(x: number, c: number[]): number`\n\nEvaluate HermiteE polynomial.\n\n**Parameters:**\n- `x` (number)\n- `c` (number[])\n\n**Returns:** `number`\n"
    },
    {
      "name": "hermevander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermevander(x: number[], deg: number): number[][]",
      "description": "",
      "content": "### hermevander\n\n`polynomial.hermevander(x: number[], deg: number): number[][]`\n\n**Parameters:**\n- `x` (number[])\n- `deg` (number)\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "hermfit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "",
      "content": "### hermfit\n\n`polynomial.hermfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\n**Parameters:**\n- `x` (number[])\n- `y` (number[])\n- `deg` (number)\n- `rcond` (null | number)\n- `full` (boolean)\n- `w` (null | number[])\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "hermfromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermfromroots(roots: number[]): number[]",
      "description": "",
      "content": "### hermfromroots\n\n`polynomial.hermfromroots(roots: number[]): number[]`\n\n**Parameters:**\n- `roots` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "",
      "content": "### hermint\n\n`polynomial.hermint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n- `k` (number[])\n- `lbnd` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermmul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermmul(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermmul\n\n`polynomial.hermmul(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermpow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermpow(c: number[], pow: number, maxpower: number): number[]",
      "description": "",
      "content": "### hermpow\n\n`polynomial.hermpow(c: number[], pow: number, maxpower: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `pow` (number)\n- `maxpower` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermroots(c: number[]): Promise<number[]>",
      "description": "",
      "content": "### hermroots\n\n`polynomial.hermroots(c: number[]): Promise<number[]>`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "hermsub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermsub(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### hermsub\n\n`polynomial.hermsub(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "hermval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermval(x: number, c: number[]): number",
      "description": "Evaluate Hermite polynomial.",
      "content": "### hermval\n\n`polynomial.hermval(x: number, c: number[]): number`\n\nEvaluate Hermite polynomial.\n\n**Parameters:**\n- `x` (number)\n- `c` (number[])\n\n**Returns:** `number`\n"
    },
    {
      "name": "hermvander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.hermvander(x: number[], deg: number): number[][]",
      "description": "",
      "content": "### hermvander\n\n`polynomial.hermvander(x: number[], deg: number): number[][]`\n\n**Parameters:**\n- `x` (number[])\n- `deg` (number)\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "lag2poly",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lag2poly(c: number[]): number[]",
      "description": "Convert Laguerre coefficients to power series.",
      "content": "### lag2poly\n\n`polynomial.lag2poly(c: number[]): number[]`\n\nConvert Laguerre coefficients to power series.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagadd(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### lagadd\n\n`polynomial.lagadd(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagcompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagcompanion(c: number[]): number[][]",
      "description": "",
      "content": "### lagcompanion\n\n`polynomial.lagcompanion(c: number[]): number[][]`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "lagder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagder(c: number[], m: number): number[]",
      "description": "",
      "content": "### lagder\n\n`polynomial.lagder(c: number[], m: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagdiv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagdiv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "",
      "content": "### lagdiv\n\n`polynomial.lagdiv(c1: number[], c2: number[]): [number[], number[]]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "lagfit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "",
      "content": "### lagfit\n\n`polynomial.lagfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\n**Parameters:**\n- `x` (number[])\n- `y` (number[])\n- `deg` (number)\n- `rcond` (null | number)\n- `full` (boolean)\n- `w` (null | number[])\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "lagfromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagfromroots(roots: number[]): number[]",
      "description": "",
      "content": "### lagfromroots\n\n`polynomial.lagfromroots(roots: number[]): number[]`\n\n**Parameters:**\n- `roots` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "",
      "content": "### lagint\n\n`polynomial.lagint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n- `k` (number[])\n- `lbnd` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagmul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagmul(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### lagmul\n\n`polynomial.lagmul(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagpow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagpow(c: number[], pow: number, maxpower: number): number[]",
      "description": "",
      "content": "### lagpow\n\n`polynomial.lagpow(c: number[], pow: number, maxpower: number): number[]`\n\n**Parameters:**\n- `c` (number[])\n- `pow` (number)\n- `maxpower` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagroots(c: number[]): Promise<number[]>",
      "description": "",
      "content": "### lagroots\n\n`polynomial.lagroots(c: number[]): Promise<number[]>`\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "lagsub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagsub(c1: number[], c2: number[]): number[]",
      "description": "",
      "content": "### lagsub\n\n`polynomial.lagsub(c1: number[], c2: number[]): number[]`\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "lagval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagval(x: number, c: number[]): number",
      "description": "Evaluate Laguerre polynomial.",
      "content": "### lagval\n\n`polynomial.lagval(x: number, c: number[]): number`\n\nEvaluate Laguerre polynomial.\n\n**Parameters:**\n- `x` (number)\n- `c` (number[])\n\n**Returns:** `number`\n"
    },
    {
      "name": "lagvander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.lagvander(x: number[], deg: number): number[][]",
      "description": "",
      "content": "### lagvander\n\n`polynomial.lagvander(x: number[], deg: number): number[][]`\n\n**Parameters:**\n- `x` (number[])\n- `deg` (number)\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "leg2poly",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.leg2poly(c: number[]): number[]",
      "description": "Convert Legendre coefficients to power series.",
      "content": "### leg2poly\n\n`polynomial.leg2poly(c: number[]): number[]`\n\nConvert Legendre coefficients to power series.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legadd(c1: number[], c2: number[]): number[]",
      "description": "Add two Legendre polynomials.",
      "content": "### legadd\n\n`polynomial.legadd(c1: number[], c2: number[]): number[]`\n\nAdd two Legendre polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legcompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legcompanion(c: number[]): number[][]",
      "description": "Generate Legendre companion matrix.",
      "content": "### legcompanion\n\n`polynomial.legcompanion(c: number[]): number[][]`\n\nGenerate Legendre companion matrix.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "legder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legder(c: number[], m: number): number[]",
      "description": "Legendre derivative.",
      "content": "### legder\n\n`polynomial.legder(c: number[], m: number): number[]`\n\nLegendre derivative.\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legdiv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legdiv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "Divide two Legendre polynomials.",
      "content": "### legdiv\n\n`polynomial.legdiv(c1: number[], c2: number[]): [number[], number[]]`\n\nDivide two Legendre polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "legfit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "Legendre least squares fit.",
      "content": "### legfit\n\n`polynomial.legfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\nLegendre least squares fit.\n\n**Parameters:**\n- `x` (number[])\n- `y` (number[])\n- `deg` (number)\n- `rcond` (null | number)\n- `full` (boolean)\n- `w` (null | number[])\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "legfromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legfromroots(roots: number[]): number[]",
      "description": "Construct Legendre polynomial from roots.",
      "content": "### legfromroots\n\n`polynomial.legfromroots(roots: number[]): number[]`\n\nConstruct Legendre polynomial from roots.\n\n**Parameters:**\n- `roots` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "Legendre integral.",
      "content": "### legint\n\n`polynomial.legint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\nLegendre integral.\n\n**Parameters:**\n- `c` (number[])\n- `m` (number)\n- `k` (number[])\n- `lbnd` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legmul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legmul(c1: number[], c2: number[]): number[]",
      "description": "Multiply two Legendre polynomials.",
      "content": "### legmul\n\n`polynomial.legmul(c1: number[], c2: number[]): number[]`\n\nMultiply two Legendre polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legpow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legpow(c: number[], pow: number, maxpower: number): number[]",
      "description": "Raise Legendre polynomial to a power.",
      "content": "### legpow\n\n`polynomial.legpow(c: number[], pow: number, maxpower: number): number[]`\n\nRaise Legendre polynomial to a power.\n\n**Parameters:**\n- `c` (number[])\n- `pow` (number)\n- `maxpower` (number)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legroots(c: number[]): Promise<number[]>",
      "description": "Find Legendre polynomial roots.",
      "content": "### legroots\n\n`polynomial.legroots(c: number[]): Promise<number[]>`\n\nFind Legendre polynomial roots.\n\n**Parameters:**\n- `c` (number[])\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "legsub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legsub(c1: number[], c2: number[]): number[]",
      "description": "Subtract two Legendre polynomials.",
      "content": "### legsub\n\n`polynomial.legsub(c1: number[], c2: number[]): number[]`\n\nSubtract two Legendre polynomials.\n\n**Parameters:**\n- `c1` (number[])\n- `c2` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "legval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legval(x: number, c: number[]): number",
      "description": "Evaluate Legendre polynomial using Clenshaw-like algorithm.",
      "content": "### legval\n\n`polynomial.legval(x: number, c: number[]): number`\n\nEvaluate Legendre polynomial using Clenshaw-like algorithm.\n\n**Parameters:**\n- `x` (number) — Point at which to evaluate\n- `c` (number[]) — Coefficient array\n\n**Returns:** `number`\n"
    },
    {
      "name": "legvander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.legvander(x: number[], deg: number): number[][]",
      "description": "Legendre Vandermonde matrix.",
      "content": "### legvander\n\n`polynomial.legvander(x: number[], deg: number): number[][]`\n\nLegendre Vandermonde matrix.\n\n**Parameters:**\n- `x` (number[])\n- `deg` (number)\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "poly2cheb",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.poly2cheb(pol: number[]): number[]",
      "description": "Convert power series coefficients to Chebyshev coefficients.",
      "content": "### poly2cheb\n\n`polynomial.poly2cheb(pol: number[]): number[]`\n\nConvert power series coefficients to Chebyshev coefficients.\n\n**Parameters:**\n- `pol` (number[]) — Power series coefficients\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "poly2herm",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.poly2herm(pol: number[]): number[]",
      "description": "Convert power series to Hermite coefficients.",
      "content": "### poly2herm\n\n`polynomial.poly2herm(pol: number[]): number[]`\n\nConvert power series to Hermite coefficients.\n\n**Parameters:**\n- `pol` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "poly2herme",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.poly2herme(pol: number[]): number[]",
      "description": "Convert power series to HermiteE coefficients.",
      "content": "### poly2herme\n\n`polynomial.poly2herme(pol: number[]): number[]`\n\nConvert power series to HermiteE coefficients.\n\n**Parameters:**\n- `pol` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "poly2lag",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.poly2lag(pol: number[]): number[]",
      "description": "Convert power series to Laguerre coefficients.",
      "content": "### poly2lag\n\n`polynomial.poly2lag(pol: number[]): number[]`\n\nConvert power series to Laguerre coefficients.\n\n**Parameters:**\n- `pol` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "poly2leg",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.poly2leg(pol: number[]): number[]",
      "description": "Convert power series to Legendre coefficients.",
      "content": "### poly2leg\n\n`polynomial.poly2leg(pol: number[]): number[]`\n\nConvert power series to Legendre coefficients.\n\n**Parameters:**\n- `pol` (number[])\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyadd",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyadd(c1: number[], c2: number[]): number[]",
      "description": "Add two coefficient arrays (power series).",
      "content": "### polyadd\n\n`polynomial.polyadd(c1: number[], c2: number[]): number[]`\n\nAdd two coefficient arrays (power series).\n\n**Parameters:**\n- `c1` (number[]) — First coefficient array\n- `c2` (number[]) — Second coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polycompanion",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polycompanion(c: number[]): number[][]",
      "description": "Generate companion matrix.",
      "content": "### polycompanion\n\n`polynomial.polycompanion(c: number[]): number[][]`\n\nGenerate companion matrix.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "polyder",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyder(c: number[], m: number): number[]",
      "description": "Polynomial derivative.",
      "content": "### polyder\n\n`polynomial.polyder(c: number[], m: number): number[]`\n\nPolynomial derivative.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `m` (number) — Number of derivatives (default: 1)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polydiv",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polydiv(c1: number[], c2: number[]): [number[], number[]]",
      "description": "Divide two coefficient arrays (power series).",
      "content": "### polydiv\n\n`polynomial.polydiv(c1: number[], c2: number[]): [number[], number[]]`\n\nDivide two coefficient arrays (power series).\n\n**Parameters:**\n- `c1` (number[]) — Dividend coefficient array\n- `c2` (number[]) — Divisor coefficient array\n\n**Returns:** `[number[], number[]]`\n"
    },
    {
      "name": "polyfit",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>",
      "description": "Least squares polynomial fit.",
      "content": "### polyfit\n\n`polynomial.polyfit(x: number[], y: number[], deg: number, rcond: null | number, full: boolean, w: null | number[]): Promise<number[] | [number[], object]>`\n\nLeast squares polynomial fit.\n\n**Parameters:**\n- `x` (number[]) — x values\n- `y` (number[]) — y values\n- `deg` (number) — Degree of fitting polynomial\n- `rcond` (null | number) — Cutoff for small singular values\n- `full` (boolean) — If true, return extra info\n- `w` (null | number[]) — Weights\n\n**Returns:** `Promise<number[] | [number[], object]>`\n"
    },
    {
      "name": "polyfromroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyfromroots(roots: number[]): number[]",
      "description": "Construct polynomial from roots.",
      "content": "### polyfromroots\n\n`polynomial.polyfromroots(roots: number[]): number[]`\n\nConstruct polynomial from roots.\n\n**Parameters:**\n- `roots` (number[]) — Array of roots\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyint",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyint(c: number[], m: number, k: number[], lbnd: number): number[]",
      "description": "Polynomial integral.",
      "content": "### polyint\n\n`polynomial.polyint(c: number[], m: number, k: number[], lbnd: number): number[]`\n\nPolynomial integral.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `m` (number) — Number of integrals (default: 1)\n- `k` (number[]) — Integration constants (default: all zero)\n- `lbnd` (number) — Lower bound (default: 0)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polymul",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polymul(c1: number[], c2: number[]): number[]",
      "description": "Multiply two coefficient arrays (power series). Uses convolution.",
      "content": "### polymul\n\n`polynomial.polymul(c1: number[], c2: number[]): number[]`\n\nMultiply two coefficient arrays (power series). Uses convolution.\n\n**Parameters:**\n- `c1` (number[]) — First coefficient array\n- `c2` (number[]) — Second coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polypow",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polypow(c: number[], pow: number, maxpower: number): number[]",
      "description": "Raise polynomial to a non-negative integer power.",
      "content": "### polypow\n\n`polynomial.polypow(c: number[], pow: number, maxpower: number): number[]`\n\nRaise polynomial to a non-negative integer power.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n- `pow` (number) — Non-negative integer power\n- `maxpower` (number) — Maximum allowed power (default: 100)\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyroots",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyroots(c: number[]): Promise<number[]>",
      "description": "Find polynomial roots.",
      "content": "### polyroots\n\n`polynomial.polyroots(c: number[]): Promise<number[]>`\n\nFind polynomial roots.\n\n**Parameters:**\n- `c` (number[]) — Coefficient array\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "polysub",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polysub(c1: number[], c2: number[]): number[]",
      "description": "Subtract two coefficient arrays (power series).",
      "content": "### polysub\n\n`polynomial.polysub(c1: number[], c2: number[]): number[]`\n\nSubtract two coefficient arrays (power series).\n\n**Parameters:**\n- `c1` (number[]) — First coefficient array\n- `c2` (number[]) — Second coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyval",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyval(x: number, c: number[]): number",
      "description": "Evaluate polynomial at x using Horner's method.",
      "content": "### polyval\n\n`polynomial.polyval(x: number, c: number[]): number`\n\nEvaluate polynomial at x using Horner's method.\n\n**Parameters:**\n- `x` (number) — Point at which to evaluate\n- `c` (number[]) — Coefficient array [c0, c1, c2, ...] for c0 + c1*x + c2*x^2 + ...\n\n**Returns:** `number`\n"
    },
    {
      "name": "polyval2d",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyval2d(x: number[], y: number[], c: number[][]): number[]",
      "description": "Evaluate 2D polynomial on x-y pairs.",
      "content": "### polyval2d\n\n`polynomial.polyval2d(x: number[], y: number[], c: number[][]): number[]`\n\nEvaluate 2D polynomial on x-y pairs.\n\n**Parameters:**\n- `x` (number[]) — x coordinates\n- `y` (number[]) — y coordinates\n- `c` (number[][]) — 2D coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyval3d",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyval3d(x: number[], y: number[], z: number[], c: number[][][]): number[]",
      "description": "Evaluate 3D polynomial on x-y-z triples.",
      "content": "### polyval3d\n\n`polynomial.polyval3d(x: number[], y: number[], z: number[], c: number[][][]): number[]`\n\nEvaluate 3D polynomial on x-y-z triples.\n\n**Parameters:**\n- `x` (number[]) — x coordinates\n- `y` (number[]) — y coordinates\n- `z` (number[]) — z coordinates\n- `c` (number[][][]) — 3D coefficient array\n\n**Returns:** `number[]`\n"
    },
    {
      "name": "polyvander",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyvander(x: number[], deg: number): number[][]",
      "description": "Generate Vandermonde matrix.",
      "content": "### polyvander\n\n`polynomial.polyvander(x: number[], deg: number): number[][]`\n\nGenerate Vandermonde matrix.\n\n**Parameters:**\n- `x` (number[]) — Sample points\n- `deg` (number) — Degree of polynomial\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "polyvander2d",
      "module": "polynomial",
      "category": "Polynomials",
      "signature": "polynomial.polyvander2d(x: number[], y: number[], deg: [number, number]): number[][]",
      "description": "Generate 2D Vandermonde matrix.",
      "content": "### polyvander2d\n\n`polynomial.polyvander2d(x: number[], y: number[], deg: [number, number]): number[][]`\n\nGenerate 2D Vandermonde matrix.\n\n**Parameters:**\n- `x` (number[]) — x sample points\n- `y` (number[]) — y sample points\n- `deg` ([number, number]) — [degree in x, degree in y]\n\n**Returns:** `number[][]`\n"
    },
    {
      "name": "AssertionError",
      "module": "testing",
      "category": "Testing",
      "signature": "class AssertionError",
      "description": "Custom error class for array assertion failures. Provides detailed comparison information.",
      "content": "### AssertionError\n\n`class AssertionError`\n\nCustom error class for array assertion failures. Provides detailed comparison information.\n"
    },
    {
      "name": "KnownFailureException",
      "module": "testing",
      "category": "Testing",
      "signature": "class KnownFailureException",
      "description": "Exception for known failures. Used to mark tests that are expected to fail.",
      "content": "### KnownFailureException\n\n`class KnownFailureException`\n\nException for known failures. Used to mark tests that are expected to fail.\n"
    },
    {
      "name": "SkipTest",
      "module": "testing",
      "category": "Testing",
      "signature": "class SkipTest",
      "description": "Exception for skipping tests. Thrown when test prerequisites are not met.",
      "content": "### SkipTest\n\n`class SkipTest`\n\nException for skipping tests. Thrown when test prerequisites are not met.\n"
    },
    {
      "name": "assert_",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_(val: unknown, msg: string): void",
      "description": "Assert a condition is true.  Unlike the built-in assert, this works in optimized mode and provides a consistent interface.",
      "content": "### assert_\n\n`testing.assert_(val: unknown, msg: string): void`\n\nAssert a condition is true.  Unlike the built-in assert, this works in optimized mode and provides a consistent interface.\n\n**Parameters:**\n- `val` (unknown) — Value to test for truthiness\n- `msg` (string) — Message to display on failure\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_allclose",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_allclose(actual: number | NDArray | number[], desired: number | NDArray | number[], rtol: number, atol: number, equal_nan: boolean, err_msg: string, _verbose: boolean): void",
      "description": "Assert that two arrays are element-wise equal within tolerance.  The comparison is:   |actual - desired| <= atol + rtol * |desired|  This is the recommended assertion for floating-point comparisons.",
      "content": "### assert_allclose\n\n`testing.assert_allclose(actual: number | NDArray | number[], desired: number | NDArray | number[], rtol: number, atol: number, equal_nan: boolean, err_msg: string, _verbose: boolean): void`\n\nAssert that two arrays are element-wise equal within tolerance.  The comparison is:   |actual - desired| <= atol + rtol * |desired|  This is the recommended assertion for floating-point comparisons.\n\n**Parameters:**\n- `actual` (number | NDArray | number[]) — Actual array\n- `desired` (number | NDArray | number[]) — Expected array\n- `rtol` (number) — Relative tolerance (default: 1e-7)\n- `atol` (number) — Absolute tolerance (default: 0)\n- `equal_nan` (boolean) — If true, NaN == NaN (default: true)\n- `err_msg` (string) — Custom error message\n- `_verbose` (boolean)\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_almost_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_almost_equal(actual: number | NDArray, desired: number | NDArray, decimal: number, err_msg: string, verbose: boolean): void",
      "description": "Assert that two values are equal up to specified decimal places.  Comparison: |actual - desired| < 10^(-decimal)  For more control over tolerances, use assert_allclose instead.",
      "content": "### assert_almost_equal\n\n`testing.assert_almost_equal(actual: number | NDArray, desired: number | NDArray, decimal: number, err_msg: string, verbose: boolean): void`\n\nAssert that two values are equal up to specified decimal places.  Comparison: |actual - desired| < 10^(-decimal)  For more control over tolerances, use assert_allclose instead.\n\n**Parameters:**\n- `actual` (number | NDArray) — Actual value or array\n- `desired` (number | NDArray) — Expected value or array\n- `decimal` (number) — Number of decimal places (default: 7)\n- `err_msg` (string) — Custom error message\n- `verbose` (boolean) — Show detailed output\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_approx_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_approx_equal(actual: number, desired: number, significant: number, err_msg: string, verbose: boolean): void",
      "description": "Assert values are equal to specified significant figures.  The comparison is relative to the scale of the expected value.",
      "content": "### assert_approx_equal\n\n`testing.assert_approx_equal(actual: number, desired: number, significant: number, err_msg: string, verbose: boolean): void`\n\nAssert values are equal to specified significant figures.  The comparison is relative to the scale of the expected value.\n\n**Parameters:**\n- `actual` (number) — Actual value\n- `desired` (number) — Expected value\n- `significant` (number) — Number of significant figures (default: 7)\n- `err_msg` (string) — Custom error message\n- `verbose` (boolean) — Show detailed output\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_array_almost_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_array_almost_equal(x: NDArray | number[], y: NDArray | number[], decimal: number, err_msg: string, verbose: boolean): void",
      "description": "Assert arrays are element-wise equal up to decimal places.  Combination of assert_array_equal and assert_almost_equal. First checks shapes, then element values.",
      "content": "### assert_array_almost_equal\n\n`testing.assert_array_almost_equal(x: NDArray | number[], y: NDArray | number[], decimal: number, err_msg: string, verbose: boolean): void`\n\nAssert arrays are element-wise equal up to decimal places.  Combination of assert_array_equal and assert_almost_equal. First checks shapes, then element values.\n\n**Parameters:**\n- `x` (NDArray | number[]) — First array\n- `y` (NDArray | number[]) — Second array\n- `decimal` (number) — Number of decimal places (default: 6)\n- `err_msg` (string) — Custom error message\n- `verbose` (boolean) — Show detailed output\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_array_compare",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_array_compare(comparison: object, x: NDArray | number[], y: NDArray | number[], header: string, precision: number): void",
      "description": "Assert arrays satisfy a custom comparison.  Low-level function for building custom assertions.",
      "content": "### assert_array_compare\n\n`testing.assert_array_compare(comparison: object, x: NDArray | number[], y: NDArray | number[], header: string, precision: number): void`\n\nAssert arrays satisfy a custom comparison.  Low-level function for building custom assertions.\n\n**Parameters:**\n- `comparison` (object) — Comparison function (a, b) => boolean\n- `x` (NDArray | number[]) — First array\n- `y` (NDArray | number[]) — Second array\n- `header` (string) — Error message header\n- `precision` (number) — Decimal places for display\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_array_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_array_equal(x: number | NDArray | number[], y: number | NDArray | number[], err_msg: string, verbose: boolean): void",
      "description": "Assert that two arrays are element-wise equal.  Compares shape and all elements. For floating-point arrays, use assert_allclose for tolerance-based comparison.",
      "content": "### assert_array_equal\n\n`testing.assert_array_equal(x: number | NDArray | number[], y: number | NDArray | number[], err_msg: string, verbose: boolean): void`\n\nAssert that two arrays are element-wise equal.  Compares shape and all elements. For floating-point arrays, use assert_allclose for tolerance-based comparison.\n\n**Parameters:**\n- `x` (number | NDArray | number[]) — First array\n- `y` (number | NDArray | number[]) — Second array\n- `err_msg` (string) — Custom error message\n- `verbose` (boolean) — Show detailed output on failure\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_array_less",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_array_less(x: number | NDArray | number[], y: number | NDArray | number[], err_msg: string, verbose: boolean): void",
      "description": "Assert that all elements of x are strictly less than those of y.",
      "content": "### assert_array_less\n\n`testing.assert_array_less(x: number | NDArray | number[], y: number | NDArray | number[], err_msg: string, verbose: boolean): void`\n\nAssert that all elements of x are strictly less than those of y.\n\n**Parameters:**\n- `x` (number | NDArray | number[]) — First array\n- `y` (number | NDArray | number[]) — Second array\n- `err_msg` (string) — Custom error message\n- `verbose` (boolean) — Show detailed output\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_array_max_ulp",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_array_max_ulp(a: NDArray | number[], b: NDArray | number[], maxulp: number, dtype: DType): number",
      "description": "Assert arrays differ by at most `maxulp` ULPs.  ULP = Unit in the Last Place (floating-point precision unit). This is the most precise way to compare floating-point numbers.",
      "content": "### assert_array_max_ulp\n\n`testing.assert_array_max_ulp(a: NDArray | number[], b: NDArray | number[], maxulp: number, dtype: DType): number`\n\nAssert arrays differ by at most `maxulp` ULPs.  ULP = Unit in the Last Place (floating-point precision unit). This is the most precise way to compare floating-point numbers.\n\n**Parameters:**\n- `a` (NDArray | number[]) — First array\n- `b` (NDArray | number[]) — Second array\n- `maxulp` (number) — Maximum ULP difference allowed (default: 1)\n- `dtype` (DType) — Data type for comparison\n\n**Returns:** `number`\n"
    },
    {
      "name": "assert_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_equal(actual: unknown, desired: unknown, err_msg: string, verbose: boolean): void",
      "description": "Assert that two objects are equal.  Handles comparison of: - Scalars (number, string, boolean) - Arrays (JavaScript arrays, nested arrays) - NDArrays (element-wise comparison) - Objects (deep equality)  Special cases: - NaN == NaN is treated as True for testing purposes - Infinity values are compared correctly",
      "content": "### assert_equal\n\n`testing.assert_equal(actual: unknown, desired: unknown, err_msg: string, verbose: boolean): void`\n\nAssert that two objects are equal.  Handles comparison of: - Scalars (number, string, boolean) - Arrays (JavaScript arrays, nested arrays) - NDArrays (element-wise comparison) - Objects (deep equality)  Special cases: - NaN == NaN is treated as True for testing purposes - Infinity values are compared correctly\n\n**Parameters:**\n- `actual` (unknown) — Actual value obtained\n- `desired` (unknown) — Expected value\n- `err_msg` (string) — Custom error message prefix\n- `verbose` (boolean) — If true, show detailed diff (default: true)\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_no_warnings",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_no_warnings(func: object, ...args: unknown[]): unknown",
      "description": "Assert that a function emits no warnings.",
      "content": "### assert_no_warnings\n\n`testing.assert_no_warnings(func: object, ...args: unknown[]): unknown`\n\nAssert that a function emits no warnings.\n\n**Parameters:**\n- `func` (object) — Function to call\n- `args` (unknown[]) (rest) — Arguments to pass to function\n\n**Returns:** `unknown`\n"
    },
    {
      "name": "assert_raises",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_raises(exception_class: object, callable: object, ...args: unknown[]): void",
      "description": "Assert that a callable raises the specified exception.",
      "content": "### assert_raises\n\n`testing.assert_raises(exception_class: object, callable: object, ...args: unknown[]): void`\n\nAssert that a callable raises the specified exception.\n\n**Parameters:**\n- `exception_class` (object) — Expected exception type\n- `callable` (object) — Function to call\n- `args` (unknown[]) (rest) — Arguments to pass to callable\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_raises_regex",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_raises_regex(exception_class: object, expected_regexp: string | RegExp, callable: object, ...args: unknown[]): void",
      "description": "Assert exception is raised with matching message.",
      "content": "### assert_raises_regex\n\n`testing.assert_raises_regex(exception_class: object, expected_regexp: string | RegExp, callable: object, ...args: unknown[]): void`\n\nAssert exception is raised with matching message.\n\n**Parameters:**\n- `exception_class` (object) — Expected exception type\n- `expected_regexp` (string | RegExp) — Regex pattern for message\n- `callable` (object) — Function to call\n- `args` (unknown[]) (rest) — Arguments to pass to callable\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_string_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_string_equal(actual: string, desired: string): void",
      "description": "Assert that two strings are equal.  Provides clear diff output for multi-line strings.",
      "content": "### assert_string_equal\n\n`testing.assert_string_equal(actual: string, desired: string): void`\n\nAssert that two strings are equal.  Provides clear diff output for multi-line strings.\n\n**Parameters:**\n- `actual` (string) — Actual string\n- `desired` (string) — Expected string\n\n**Returns:** `void`\n"
    },
    {
      "name": "assert_warns",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.assert_warns(warning_class: object, callable: object, ...args: unknown[]): unknown",
      "description": "Assert that a function emits a warning.  Note: JavaScript doesn't have built-in warnings. This integrates with a custom warning system if available.",
      "content": "### assert_warns\n\n`testing.assert_warns(warning_class: object, callable: object, ...args: unknown[]): unknown`\n\nAssert that a function emits a warning.  Note: JavaScript doesn't have built-in warnings. This integrates with a custom warning system if available.\n\n**Parameters:**\n- `warning_class` (object) — Expected warning type\n- `callable` (object) — Function to call\n- `args` (unknown[]) (rest) — Arguments to pass to callable\n\n**Returns:** `unknown`\n"
    },
    {
      "name": "measure",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.measure(code: object, times: number): number",
      "description": "Measure execution time of a code block.",
      "content": "### measure\n\n`testing.measure(code: object, times: number): number`\n\nMeasure execution time of a code block.\n\n**Parameters:**\n- `code` (object) — Function to benchmark\n- `times` (number) — Number of iterations (default: 1)\n\n**Returns:** `number`\n"
    },
    {
      "name": "print_assert_equal",
      "module": "testing",
      "category": "Testing",
      "signature": "testing.print_assert_equal(test_string: string, actual: unknown, desired: unknown): void",
      "description": "Print comparison result for debugging.",
      "content": "### print_assert_equal\n\n`testing.print_assert_equal(test_string: string, actual: unknown, desired: unknown): void`\n\nPrint comparison result for debugging.\n\n**Parameters:**\n- `test_string` (string) — Description of test\n- `actual` (unknown) — Actual value\n- `desired` (unknown) — Expected value\n\n**Returns:** `void`\n"
    },
    {
      "name": "NDArray",
      "module": null,
      "category": "Array Creation",
      "signature": "class NDArray",
      "description": "",
      "content": "### NDArray\n\n`class NDArray`\n\n**Methods:**\n- `ascontiguousarray(): NDArray` — Return a C-contiguous array. Returns a view if already contiguous, otherwise a copy.\n- `asfortranarray(): NDArray` — Return a Fortran-contiguous (column-major) array. Returns a view if already F-contiguous, otherwise a copy.\n- `astype(dtype: DType): NDArray` — Create a copy with a different dtype.\n- `at(index: number): NDArray` — Get a sub-array by integer index along axis 0. Returns a view with ndim-1 dimensions.\n- `copy(): NDArray` — Create a deep copy of the array.\n- `dispose(): void` — Free the underlying WASM memory.  After calling dispose(), the array can no longer be used. Always call dispose() when done with an array to prevent memory leaks.\n- `expandDims(axis: number): NDArray` — Add a size-1 dimension at the specified position. Returns a view.\n- `fill(value: number): void` — Fill the array with a constant value.\n- `flatten(): NDArray` — Return a flattened array (always a copy).\n- `get(...indices: number[]): number` — Get element at specified indices.\n- `getComplex(...indices: number[]): Complex` — Get complex element at indices.\n- `getFlat(index: number): number` — Get element at flat index.\n- `getStringFlat(index: number): string` — Get string element at flat index. Only valid for string arrays.\n- `item(): number` — Get single element for scalar or single-element array.\n- `itemset(value: number): void` — Set single element for scalar or single-element array.\n- `moveaxis(source: number | number[], destination: number | number[]): NDArray` — Move axes of an array to new positions. Other axes remain in their original order. Returns a view.\n- `ravel(): NDArray` — Return a flattened array as a view (if contiguous) or copy.\n- `reshape(newShape: number[]): NDArray` — Returns an array with the given shape. Returns a view if the array is contiguous.\n- `set(value: number, ...indices: number[]): void` — Set element at specified indices.\n- `setComplex(real: number, imag: number, ...indices: number[]): void` — Set complex element at indices.\n- `setFlat(index: number, value: number): void` — Set element at flat index.\n- `setStringFlat(index: number, value: string): void` — Set string element at flat index. Only valid for string arrays.\n- `slice(indices: IndexElement[]): NDArray` — Slice the array using NumPy-style indexing.\n- `squeeze(axis?: number): NDArray` — Remove size-1 dimensions from the array. Returns a view.\n- `sum(): number` — Compute the sum of all elements.  Uses NumPy's pairwise summation algorithm for O(lg n) rounding error instead of O(n) for naive summation.\n- `swapaxes(axis1: number, axis2: number): NDArray` — Swap two axes of the array. Returns a view.\n- `toArray(): number[] | string[]` — Get array data as a JavaScript array.\n- `tofile(file: string | FileSystemFileHandle, options: object): Promise<void>` — Write array to a file as binary or text.\n- `toTypedArray(): Float64Array<ArrayBufferLike> | Float32Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Int8Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike>` — Get array data as a TypedArray.\n- `transpose(axes?: number[]): NDArray` — Transpose array with optional custom axes permutation. Always returns a view.\n- `view(shape?: number[], strides?: number[]): NDArray` — Create a view of this array with different shape/strides.\n- `viewDtype(dtype: DType): NDArray` — Create a view with a different dtype interpretation. The array must be C-contiguous.\n- `arange(start: number, end?: number, step: number): Promise<NDArray>` — Create an NDArray with evenly spaced values.\n- `diag(v: NDArray, k: number): Promise<NDArray>` — Extract a diagonal or construct a diagonal array.\n- `empty(shape: number[], options: NDArrayOptions): Promise<NDArray>` — Create a new NDArray without initializing values. Faster than zeros() but contains arbitrary values.\n- `emptyLike(arr: NDArray, options: NDArrayOptions): Promise<NDArray>` — Create uninitialized array with same shape and dtype as another array.\n- `emptyString(shape: number[]): NDArray` — Create an empty string array with the given shape. All elements are initialized to empty strings.\n- `eye(N: number, M?: number, k: number, options: NDArrayOptions): Promise<NDArray>` — Create a 2D array with ones on the diagonal and zeros elsewhere.\n- `fromArray(data: NestedArray | Float64Array<ArrayBufferLike> | Float32Array<ArrayBufferLike> | Int32Array<ArrayBufferLike>, shape?: number[], options: NDArrayOptions): Promise<NDArray>` — Create an NDArray from existing JavaScript data.\n- `fromStringArray(data: string[] | string[][], shape?: number[]): NDArray` — Create a string array from a JavaScript string array. This is a synchronous operation (no WASM involved).\n- `fromTypedArray(typedArray: Float64Array<ArrayBufferLike> | Float32Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Int8Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, shape: number[], dtype?: DType): Promise<NDArray>` — Create an NDArray from a TypedArray.\n- `full(shape: number[], fillValue: number, options: NDArrayOptions): Promise<NDArray>` — Create a new NDArray filled with a constant value.\n- `fullLike(arr: NDArray, fillValue: number, options: NDArrayOptions): Promise<NDArray>` — Create array with same shape as another array, filled with a value.\n- `geomspace(start: number, stop: number, num: number, endpoint: boolean, options: NDArrayOptions): Promise<NDArray>` — Create an NDArray with numbers spaced evenly on a geometric scale.\n- `identity(n: number, options: NDArrayOptions): Promise<NDArray>` — Create a square identity matrix.\n- `linspace(start: number, stop: number, num: number, endpoint: boolean, options: NDArrayOptions): Promise<NDArray>` — Create an NDArray with evenly spaced numbers over an interval.\n- `logspace(start: number, stop: number, num: number, endpoint: boolean, base: number, options: NDArrayOptions): Promise<NDArray>` — Create an NDArray with numbers spaced evenly on a log scale.\n- `ones(shape: number[], options: NDArrayOptions): Promise<NDArray>` — Create a new NDArray filled with ones.\n- `onesLike(arr: NDArray, options: NDArrayOptions): Promise<NDArray>` — Create array with same shape and dtype as another array, filled with ones.\n- `tri(N: number, M?: number, k: number, options: NDArrayOptions): Promise<NDArray>` — Create array with ones at and below diagonal, zeros elsewhere.\n- `tril(arr: NDArray, k: number): Promise<NDArray>` — Lower triangle of an array.\n- `triu(arr: NDArray, k: number): Promise<NDArray>` — Upper triangle of an array.\n- `zeros(shape: number[], options: NDArrayOptions): Promise<NDArray>` — Create a new NDArray filled with zeros.\n- `zerosLike(arr: NDArray, options: NDArrayOptions): Promise<NDArray>` — Create array with same shape and dtype as another array, filled with zeros.\n"
    },
    {
      "name": "asarray",
      "module": null,
      "category": "Array Creation",
      "signature": "asarray(a: number | NDArray | number[], dtype?: DType): Promise<NDArray>",
      "description": "Convert the input to an array.",
      "content": "### asarray\n\n`asarray(a: number | NDArray | number[], dtype?: DType): Promise<NDArray>`\n\nConvert the input to an array.\n\n**Parameters:**\n- `a` (number | NDArray | number[]) — Input data\n- `dtype` (DType) (optional) — Optional data type\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "broadcastArrays",
      "module": null,
      "category": "Array Creation",
      "signature": "broadcastArrays(...arrays: NDArray[]): Promise<NDArray[]>",
      "description": "Broadcast any number of arrays against each other.  Returns views of the arrays with the same shape. All returned arrays share data with their originals.",
      "content": "### broadcastArrays\n\n`broadcastArrays(...arrays: NDArray[]): Promise<NDArray[]>`\n\nBroadcast any number of arrays against each other.  Returns views of the arrays with the same shape. All returned arrays share data with their originals.\n\n**Parameters:**\n- `arrays` (NDArray[]) (rest) — Arrays to broadcast together\n\n**Returns:** `Promise<NDArray[]>`\n"
    },
    {
      "name": "broadcastShapes",
      "module": null,
      "category": "Array Creation",
      "signature": "broadcastShapes(shape1: number[], shape2: number[]): Promise<null | number[]>",
      "description": "Compute the broadcast shape for two shapes.",
      "content": "### broadcastShapes\n\n`broadcastShapes(shape1: number[], shape2: number[]): Promise<null | number[]>`\n\nCompute the broadcast shape for two shapes.\n\n**Parameters:**\n- `shape1` (number[]) — First shape\n- `shape2` (number[]) — Second shape\n\n**Returns:** `Promise<null | number[]>`\n"
    },
    {
      "name": "broadcastShapesMulti",
      "module": null,
      "category": "Array Creation",
      "signature": "broadcastShapesMulti(shapes: number[][]): Promise<null | number[]>",
      "description": "Compute the broadcast shape for multiple shapes.",
      "content": "### broadcastShapesMulti\n\n`broadcastShapesMulti(shapes: number[][]): Promise<null | number[]>`\n\nCompute the broadcast shape for multiple shapes.\n\n**Parameters:**\n- `shapes` (number[][]) — Array of shapes\n\n**Returns:** `Promise<null | number[]>`\n"
    },
    {
      "name": "broadcastTo",
      "module": null,
      "category": "Array Creation",
      "signature": "broadcastTo(arr: NDArray, targetShape: number[]): Promise<NDArray>",
      "description": "Broadcast an array to a target shape.  Returns a view of the array with the target shape. The view shares data with the original array but has zero strides for broadcast dimensions.",
      "content": "### broadcastTo\n\n`broadcastTo(arr: NDArray, targetShape: number[]): Promise<NDArray>`\n\nBroadcast an array to a target shape.  Returns a view of the array with the target shape. The view shares data with the original array but has zero strides for broadcast dimensions.\n\n**Parameters:**\n- `arr` (NDArray) — Array to broadcast\n- `targetShape` (number[]) — Target shape\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "diag_indices",
      "module": null,
      "category": "Array Creation",
      "signature": "diag_indices(n: number, ndim: number): Promise<NDArray[]>",
      "description": "Return the indices to access the main diagonal of an array.",
      "content": "### diag_indices\n\n`diag_indices(n: number, ndim: number): Promise<NDArray[]>`\n\nReturn the indices to access the main diagonal of an array.\n\n**Parameters:**\n- `n` (number) — Size of the array (along each dimension)\n- `ndim` (number) — Number of dimensions (default: 2)\n\n**Returns:** `Promise<NDArray[]>`\n"
    },
    {
      "name": "frombuffer",
      "module": null,
      "category": "Array Creation",
      "signature": "frombuffer(buffer: ArrayBuffer | ArrayBufferView<ArrayBufferLike>, options: FrombufferOptions): Promise<NDArray>",
      "description": "Interpret a buffer as a 1-dimensional array.",
      "content": "### frombuffer\n\n`frombuffer(buffer: ArrayBuffer | ArrayBufferView<ArrayBufferLike>, options: FrombufferOptions): Promise<NDArray>`\n\nInterpret a buffer as a 1-dimensional array.\n\n**Parameters:**\n- `buffer` (ArrayBuffer | ArrayBufferView<ArrayBufferLike>) — Buffer containing array data\n- `options` (FrombufferOptions) — Interpretation options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "fromfile",
      "module": null,
      "category": "Array Creation",
      "signature": "fromfile(file: string | ArrayBuffer | File | URL, options: FromfileOptions): Promise<NDArray>",
      "description": "Construct an array from data in a binary file.",
      "content": "### fromfile\n\n`fromfile(file: string | ArrayBuffer | File | URL, options: FromfileOptions): Promise<NDArray>`\n\nConstruct an array from data in a binary file.\n\n**Parameters:**\n- `file` (string | ArrayBuffer | File | URL) — File source (path, File object, URL, or ArrayBuffer)\n- `options` (FromfileOptions) — Reading options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "fromregex",
      "module": null,
      "category": "Array Creation",
      "signature": "fromregex(file: string | File | URL, regexp: RegExp, dtype: DType, options: FromregexOptions): Promise<NDArray>",
      "description": "Construct an array from a text file using regular expression parsing.",
      "content": "### fromregex\n\n`fromregex(file: string | File | URL, regexp: RegExp, dtype: DType, options: FromregexOptions): Promise<NDArray>`\n\nConstruct an array from a text file using regular expression parsing.\n\n**Parameters:**\n- `file` (string | File | URL) — File source\n- `regexp` (RegExp) — Regular expression with groups to extract\n- `dtype` (DType) — Output data type\n- `options` (FromregexOptions) — Additional options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "genfromtxt",
      "module": null,
      "category": "Array Creation",
      "signature": "genfromtxt(file: string | File | URL, options: GenfromtxtOptions): Promise<NDArray>",
      "description": "Load data from a text file with handling for missing values. More sophisticated than loadtxt, supports missing value replacement.",
      "content": "### genfromtxt\n\n`genfromtxt(file: string | File | URL, options: GenfromtxtOptions): Promise<NDArray>`\n\nLoad data from a text file with handling for missing values. More sophisticated than loadtxt, supports missing value replacement.\n\n**Parameters:**\n- `file` (string | File | URL) — File source\n- `options` (GenfromtxtOptions) — Parsing options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "indices",
      "module": null,
      "category": "Array Creation",
      "signature": "indices(dimensions: number[], dtype: DType, sparse: boolean): Promise<NDArray | NDArray[]>",
      "description": "Return an array representing the indices of a grid.",
      "content": "### indices\n\n`indices(dimensions: number[], dtype: DType, sparse: boolean): Promise<NDArray | NDArray[]>`\n\nReturn an array representing the indices of a grid.\n\n**Parameters:**\n- `dimensions` (number[]) — The shape of the grid\n- `dtype` (DType) — Data type of the result (default: Int32)\n- `sparse` (boolean) — Return sparse representation (default: false)\n\n**Returns:** `Promise<NDArray | NDArray[]>`\n"
    },
    {
      "name": "ix_",
      "module": null,
      "category": "Array Creation",
      "signature": "ix_(...args: NDArray | number[][]): Promise<NDArray[]>",
      "description": "Construct an open mesh from multiple sequences. This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape in the ith dimension is the length of the ith input.",
      "content": "### ix_\n\n`ix_(...args: NDArray | number[][]): Promise<NDArray[]>`\n\nConstruct an open mesh from multiple sequences. This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape in the ith dimension is the length of the ith input.\n\n**Parameters:**\n- `args` (NDArray | number[][]) (rest) — 1-D sequences (arrays or NDArrays)\n\n**Returns:** `Promise<NDArray[]>`\n"
    },
    {
      "name": "load",
      "module": null,
      "category": "Array Creation",
      "signature": "load(file: string | ArrayBuffer | File | URL, _options: LoadOptions): Promise<NDArray>",
      "description": "Load an array from a NPY file.",
      "content": "### load\n\n`load(file: string | ArrayBuffer | File | URL, _options: LoadOptions): Promise<NDArray>`\n\nLoad an array from a NPY file.\n\n**Parameters:**\n- `file` (string | ArrayBuffer | File | URL) — File path (Node.js), File object (browser), ArrayBuffer, or URL\n- `_options` (LoadOptions)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "loadtxt",
      "module": null,
      "category": "Array Creation",
      "signature": "loadtxt(file: string | File | URL, options: LoadtxtOptions): Promise<NDArray>",
      "description": "Load data from a text file.  Each row in the text file must have the same number of values.",
      "content": "### loadtxt\n\n`loadtxt(file: string | File | URL, options: LoadtxtOptions): Promise<NDArray>`\n\nLoad data from a text file.  Each row in the text file must have the same number of values.\n\n**Parameters:**\n- `file` (string | File | URL) — File source (path, File object, or URL)\n- `options` (LoadtxtOptions) — Parsing options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "meshgrid",
      "module": null,
      "category": "Array Creation",
      "signature": "meshgrid(...xi: NDArray | number[][]): Promise<NDArray[]>",
      "description": "Return coordinate matrices from coordinate vectors.",
      "content": "### meshgrid\n\n`meshgrid(...xi: NDArray | number[][]): Promise<NDArray[]>`\n\nReturn coordinate matrices from coordinate vectors.\n\n**Parameters:**\n- `xi` (NDArray | number[][]) (rest) — 1D coordinate arrays\n\n**Returns:** `Promise<NDArray[]>`\n"
    },
    {
      "name": "tril_indices",
      "module": null,
      "category": "Array Creation",
      "signature": "tril_indices(n: number, k: number, m?: number): Promise<[NDArray, NDArray]>",
      "description": "Return the indices for the lower-triangle of an (n, m) array.",
      "content": "### tril_indices\n\n`tril_indices(n: number, k: number, m?: number): Promise<[NDArray, NDArray]>`\n\nReturn the indices for the lower-triangle of an (n, m) array.\n\n**Parameters:**\n- `n` (number) — Number of rows\n- `k` (number) — Diagonal offset (default: 0, main diagonal)\n- `m` (number) (optional) — Number of columns (default: n)\n\n**Returns:** `Promise<[NDArray, NDArray]>`\n"
    },
    {
      "name": "triu_indices",
      "module": null,
      "category": "Array Creation",
      "signature": "triu_indices(n: number, k: number, m?: number): Promise<[NDArray, NDArray]>",
      "description": "Return the indices for the upper-triangle of an (n, m) array.",
      "content": "### triu_indices\n\n`triu_indices(n: number, k: number, m?: number): Promise<[NDArray, NDArray]>`\n\nReturn the indices for the upper-triangle of an (n, m) array.\n\n**Parameters:**\n- `n` (number) — Number of rows\n- `k` (number) — Diagonal offset (default: 0, main diagonal)\n- `m` (number) (optional) — Number of columns (default: n)\n\n**Returns:** `Promise<[NDArray, NDArray]>`\n"
    },
    {
      "name": "append",
      "module": null,
      "category": "Array Manipulation",
      "signature": "append(arr: NDArray, values: NDArray, axis?: number): NDArray",
      "description": "Append values to the end of an array.",
      "content": "### append\n\n`append(arr: NDArray, values: NDArray, axis?: number): NDArray`\n\nAppend values to the end of an array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `values` (NDArray) — Values to append\n- `axis` (number) (optional) — Axis along which to append (default: flatten both)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "array_split",
      "module": null,
      "category": "Array Manipulation",
      "signature": "array_split(arr: NDArray, indices_or_sections: number | number[], axis: number): NDArray[]",
      "description": "Split an array into multiple sub-arrays as views. Allows unequal division (unlike split).",
      "content": "### array_split\n\n`array_split(arr: NDArray, indices_or_sections: number | number[], axis: number): NDArray[]`\n\nSplit an array into multiple sub-arrays as views. Allows unequal division (unlike split).\n\n**Parameters:**\n- `arr` (NDArray) — Array to split\n- `indices_or_sections` (number | number[]) — Number of sections or split indices\n- `axis` (number) — Axis along which to split (default: 0)\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "atleast_1d",
      "module": null,
      "category": "Array Manipulation",
      "signature": "atleast_1d(...arrs: NDArray[]): NDArray | NDArray[]",
      "description": "Convert inputs to arrays with at least one dimension. Scalar inputs are converted to 1D arrays. Higher-dimensional inputs are unchanged.",
      "content": "### atleast_1d\n\n`atleast_1d(...arrs: NDArray[]): NDArray | NDArray[]`\n\nConvert inputs to arrays with at least one dimension. Scalar inputs are converted to 1D arrays. Higher-dimensional inputs are unchanged.\n\n**Parameters:**\n- `arrs` (NDArray[]) (rest) — Input arrays\n\n**Returns:** `NDArray | NDArray[]`\n"
    },
    {
      "name": "atleast_2d",
      "module": null,
      "category": "Array Manipulation",
      "signature": "atleast_2d(...arrs: NDArray[]): NDArray | NDArray[]",
      "description": "View inputs as arrays with at least two dimensions.",
      "content": "### atleast_2d\n\n`atleast_2d(...arrs: NDArray[]): NDArray | NDArray[]`\n\nView inputs as arrays with at least two dimensions.\n\n**Parameters:**\n- `arrs` (NDArray[]) (rest) — Input arrays\n\n**Returns:** `NDArray | NDArray[]`\n"
    },
    {
      "name": "atleast_3d",
      "module": null,
      "category": "Array Manipulation",
      "signature": "atleast_3d(...arrs: NDArray[]): NDArray | NDArray[]",
      "description": "View inputs as arrays with at least three dimensions.",
      "content": "### atleast_3d\n\n`atleast_3d(...arrs: NDArray[]): NDArray | NDArray[]`\n\nView inputs as arrays with at least three dimensions.\n\n**Parameters:**\n- `arrs` (NDArray[]) (rest) — Input arrays\n\n**Returns:** `NDArray | NDArray[]`\n"
    },
    {
      "name": "block",
      "module": null,
      "category": "Array Manipulation",
      "signature": "block(arrays: NDArray | NDArray[][]): NDArray",
      "description": "Assemble an nd-array from nested lists of blocks.",
      "content": "### block\n\n`block(arrays: NDArray | NDArray[][]): NDArray`\n\nAssemble an nd-array from nested lists of blocks.\n\n**Parameters:**\n- `arrays` (NDArray | NDArray[][]) — Nested list of arrays (1D list for hstack, 2D for block assembly)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "choose",
      "module": null,
      "category": "Array Manipulation",
      "signature": "choose(indices: NDArray, choices: NDArray[], mode: ClipMode): Promise<NDArray>",
      "description": "Construct an array from an index array and a set of arrays to choose from.",
      "content": "### choose\n\n`choose(indices: NDArray, choices: NDArray[], mode: ClipMode): Promise<NDArray>`\n\nConstruct an array from an index array and a set of arrays to choose from.\n\n**Parameters:**\n- `indices` (NDArray) — Array of indices into choices\n- `choices` (NDArray[]) — Array of choice arrays\n- `mode` (ClipMode) — How to handle out-of-bounds indices (default: 'raise')\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "column_stack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "column_stack(tup: NDArray[]): NDArray",
      "description": "Stack 1-D arrays as columns into a 2-D array.",
      "content": "### column_stack\n\n`column_stack(tup: NDArray[]): NDArray`\n\nStack 1-D arrays as columns into a 2-D array.\n\n**Parameters:**\n- `tup` (NDArray[]) — Sequence of 1-D or 2-D arrays\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "compress",
      "module": null,
      "category": "Array Manipulation",
      "signature": "compress(condition: NDArray, arr: NDArray, axis: number): Promise<NDArray>",
      "description": "Return selected slices of an array along given axis.",
      "content": "### compress\n\n`compress(condition: NDArray, arr: NDArray, axis: number): Promise<NDArray>`\n\nReturn selected slices of an array along given axis.\n\n**Parameters:**\n- `condition` (NDArray) — Boolean 1D array selecting which slices to keep\n- `arr` (NDArray) — Input array\n- `axis` (number) — Axis along which to select (default: 0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "concatenate",
      "module": null,
      "category": "Array Manipulation",
      "signature": "concatenate(arrays: NDArray[], axis: number, dtype?: DType): NDArray",
      "description": "Join a sequence of arrays along an existing axis.",
      "content": "### concatenate\n\n`concatenate(arrays: NDArray[], axis: number, dtype?: DType): NDArray`\n\nJoin a sequence of arrays along an existing axis.\n\n**Parameters:**\n- `arrays` (NDArray[]) — Sequence of arrays to concatenate\n- `axis` (number) — The axis along which to concatenate (default: 0)\n- `dtype` (DType) (optional) — Optional dtype for the output array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "copyto",
      "module": null,
      "category": "Array Manipulation",
      "signature": "copyto(dst: NDArray, src: NDArray, _casting: string, where?: NDArray): void",
      "description": "Copy values from one array to another, broadcasting as necessary.",
      "content": "### copyto\n\n`copyto(dst: NDArray, src: NDArray, _casting: string, where?: NDArray): void`\n\nCopy values from one array to another, broadcasting as necessary.\n\n**Parameters:**\n- `dst` (NDArray) — Destination array\n- `src` (NDArray) — Source array\n- `_casting` (string)\n- `where` (NDArray) (optional) — Optional boolean mask array\n\n**Returns:** `void`\n"
    },
    {
      "name": "deleteArr",
      "module": null,
      "category": "Array Manipulation",
      "signature": "deleteArr(arr: NDArray, obj: number | number[], axis?: number): Promise<NDArray>",
      "description": "Return a new array with sub-arrays along an axis deleted.",
      "content": "### deleteArr\n\n`deleteArr(arr: NDArray, obj: number | number[], axis?: number): Promise<NDArray>`\n\nReturn a new array with sub-arrays along an axis deleted.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `obj` (number | number[]) — Index or indices to delete\n- `axis` (number) (optional) — Axis along which to delete (default: flatten first)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "diagonal",
      "module": null,
      "category": "Array Manipulation",
      "signature": "diagonal(arr: NDArray, offset: number, axis1: number, axis2: number): Promise<NDArray>",
      "description": "Return specified diagonals from a 2D array.",
      "content": "### diagonal\n\n`diagonal(arr: NDArray, offset: number, axis1: number, axis2: number): Promise<NDArray>`\n\nReturn specified diagonals from a 2D array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array (must be 2D)\n- `offset` (number) — Offset from main diagonal (default: 0)\n- `axis1` (number)\n- `axis2` (number)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "dsplit",
      "module": null,
      "category": "Array Manipulation",
      "signature": "dsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]",
      "description": "Split array into multiple sub-arrays along the 3rd axis (depth).",
      "content": "### dsplit\n\n`dsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]`\n\nSplit array into multiple sub-arrays along the 3rd axis (depth).\n\n**Parameters:**\n- `arr` (NDArray) — Array with at least 3 dimensions\n- `indices_or_sections` (number | number[]) — Number of sections or split indices\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "dstack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "dstack(tup: NDArray[]): NDArray",
      "description": "Stack arrays in sequence along the third axis (depth-wise).",
      "content": "### dstack\n\n`dstack(tup: NDArray[]): NDArray`\n\nStack arrays in sequence along the third axis (depth-wise).\n\n**Parameters:**\n- `tup` (NDArray[]) — Sequence of arrays\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ediff1d",
      "module": null,
      "category": "Array Manipulation",
      "signature": "ediff1d(arr: NDArray, options: Ediff1dOptions): Promise<NDArray>",
      "description": "Compute the differences between consecutive elements of an array.  This is implemented in TypeScript as it's straightforward and doesn't require WASM for performance.",
      "content": "### ediff1d\n\n`ediff1d(arr: NDArray, options: Ediff1dOptions): Promise<NDArray>`\n\nCompute the differences between consecutive elements of an array.  This is implemented in TypeScript as it's straightforward and doesn't require WASM for performance.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `options` (Ediff1dOptions) — Configuration options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "extract",
      "module": null,
      "category": "Array Manipulation",
      "signature": "extract(condition: NDArray, arr: NDArray): Promise<NDArray>",
      "description": "Return elements of an array that satisfy some condition.",
      "content": "### extract\n\n`extract(condition: NDArray, arr: NDArray): Promise<NDArray>`\n\nReturn elements of an array that satisfy some condition.\n\n**Parameters:**\n- `condition` (NDArray) — Boolean array, same shape as arr\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "flip",
      "module": null,
      "category": "Array Manipulation",
      "signature": "flip(arr: NDArray, axis?: number | number[]): NDArray",
      "description": "Reverse the order of elements in an array along the given axis.",
      "content": "### flip\n\n`flip(arr: NDArray, axis?: number | number[]): NDArray`\n\nReverse the order of elements in an array along the given axis.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `axis` (number | number[]) (optional) — Axis or axes along which to flip. Default is to flip all axes.\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fliplr",
      "module": null,
      "category": "Array Manipulation",
      "signature": "fliplr(arr: NDArray): NDArray",
      "description": "Reverse the order of elements along axis 1 (left/right).",
      "content": "### fliplr\n\n`fliplr(arr: NDArray): NDArray`\n\nReverse the order of elements along axis 1 (left/right).\n\n**Parameters:**\n- `arr` (NDArray) — Input array with at least 2 dimensions\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "flipud",
      "module": null,
      "category": "Array Manipulation",
      "signature": "flipud(arr: NDArray): NDArray",
      "description": "Reverse the order of elements along axis 0 (up/down).",
      "content": "### flipud\n\n`flipud(arr: NDArray): NDArray`\n\nReverse the order of elements along axis 0 (up/down).\n\n**Parameters:**\n- `arr` (NDArray) — Input array with at least 1 dimension\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "hsplit",
      "module": null,
      "category": "Array Manipulation",
      "signature": "hsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]",
      "description": "Split an array into multiple sub-arrays horizontally (column-wise).",
      "content": "### hsplit\n\n`hsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]`\n\nSplit an array into multiple sub-arrays horizontally (column-wise).\n\n**Parameters:**\n- `arr` (NDArray) — Array\n- `indices_or_sections` (number | number[]) — Number of sections or split indices\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "hstack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "hstack(tup: NDArray[]): NDArray",
      "description": "Stack arrays in sequence horizontally (column-wise). For 1-D arrays, concatenates along axis 0. For 2-D+ arrays, concatenates along axis 1.",
      "content": "### hstack\n\n`hstack(tup: NDArray[]): NDArray`\n\nStack arrays in sequence horizontally (column-wise). For 1-D arrays, concatenates along axis 0. For 2-D+ arrays, concatenates along axis 1.\n\n**Parameters:**\n- `tup` (NDArray[]) — Sequence of arrays\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "insert",
      "module": null,
      "category": "Array Manipulation",
      "signature": "insert(arr: NDArray, obj: number | number[], values: NDArray, axis?: number): NDArray",
      "description": "Insert values along the given axis before the given indices.",
      "content": "### insert\n\n`insert(arr: NDArray, obj: number | number[], values: NDArray, axis?: number): NDArray`\n\nInsert values along the given axis before the given indices.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `obj` (number | number[]) — Index or indices before which values are inserted\n- `values` (NDArray) — Values to insert\n- `axis` (number) (optional) — Axis along which to insert (default: flatten first)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "pad",
      "module": null,
      "category": "Array Manipulation",
      "signature": "pad(arr: NDArray, pad_width: number | [number, number] | [number, number][], mode: string, constant_values: number): Promise<NDArray>",
      "description": "Pad an array.",
      "content": "### pad\n\n`pad(arr: NDArray, pad_width: number | [number, number] | [number, number][], mode: string, constant_values: number): Promise<NDArray>`\n\nPad an array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `pad_width` (number | [number, number] | [number, number][]) — Number of values padded to edges of each axis\n- `mode` (string) — Padding mode (default: 'constant')\n- `constant_values` (number) — Value to use for constant padding (default: 0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "place",
      "module": null,
      "category": "Array Manipulation",
      "signature": "place(arr: NDArray, mask: NDArray, vals: NDArray): Promise<void>",
      "description": "Change elements of an array based on conditional and input values. Similar to putmask, but places values sequentially.",
      "content": "### place\n\n`place(arr: NDArray, mask: NDArray, vals: NDArray): Promise<void>`\n\nChange elements of an array based on conditional and input values. Similar to putmask, but places values sequentially.\n\n**Parameters:**\n- `arr` (NDArray) — Array to modify (in place)\n- `mask` (NDArray) — Boolean mask array\n- `vals` (NDArray) — Values to place (used sequentially, cycled if needed)\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "put",
      "module": null,
      "category": "Array Manipulation",
      "signature": "put(arr: NDArray, indices: NDArray, values: NDArray, mode: ClipMode): Promise<void>",
      "description": "Put values into an array at specified flat indices.",
      "content": "### put\n\n`put(arr: NDArray, indices: NDArray, values: NDArray, mode: ClipMode): Promise<void>`\n\nPut values into an array at specified flat indices.\n\n**Parameters:**\n- `arr` (NDArray) — Target array (modified in place)\n- `indices` (NDArray) — Array of flat indices\n- `values` (NDArray) — Values to put (broadcast if smaller)\n- `mode` (ClipMode) — How to handle out-of-bounds indices (default: 'raise')\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "put_along_axis",
      "module": null,
      "category": "Array Manipulation",
      "signature": "put_along_axis(arr: NDArray, indicesArr: NDArray, values: NDArray, axis: number): Promise<void>",
      "description": "Put values into the destination array by matching 1d index and data slices.",
      "content": "### put_along_axis\n\n`put_along_axis(arr: NDArray, indicesArr: NDArray, values: NDArray, axis: number): Promise<void>`\n\nPut values into the destination array by matching 1d index and data slices.\n\n**Parameters:**\n- `arr` (NDArray) — Destination array (modified in place)\n- `indicesArr` (NDArray)\n- `values` (NDArray) — Values to put\n- `axis` (number) — The axis to put along\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "putmask",
      "module": null,
      "category": "Array Manipulation",
      "signature": "putmask(arr: NDArray, mask: NDArray, values: NDArray): Promise<void>",
      "description": "Change elements of an array based on conditional and input values. Sets a.flat[n] = values[n % len(values)] for each n where mask.flat[n]==True.",
      "content": "### putmask\n\n`putmask(arr: NDArray, mask: NDArray, values: NDArray): Promise<void>`\n\nChange elements of an array based on conditional and input values. Sets a.flat[n] = values[n % len(values)] for each n where mask.flat[n]==True.\n\n**Parameters:**\n- `arr` (NDArray) — Array to modify (in place)\n- `mask` (NDArray) — Boolean mask array\n- `values` (NDArray) — Values to put (cycled if smaller than number of True in mask)\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "repeat",
      "module": null,
      "category": "Array Manipulation",
      "signature": "repeat(arr: NDArray, repeats: number | number[], axis?: number): Promise<NDArray>",
      "description": "Repeat elements of an array.",
      "content": "### repeat\n\n`repeat(arr: NDArray, repeats: number | number[], axis?: number): Promise<NDArray>`\n\nRepeat elements of an array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `repeats` (number | number[]) — Number of repetitions for each element\n- `axis` (number) (optional) — Axis along which to repeat (default: flatten first)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "resize",
      "module": null,
      "category": "Array Manipulation",
      "signature": "resize(arr: NDArray, new_shape: number[]): Promise<NDArray>",
      "description": "Return a new array with the specified shape. If the new array is larger than the original, it is filled with repeated copies.",
      "content": "### resize\n\n`resize(arr: NDArray, new_shape: number[]): Promise<NDArray>`\n\nReturn a new array with the specified shape. If the new array is larger than the original, it is filled with repeated copies.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `new_shape` (number[]) — Shape of the resized array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "roll",
      "module": null,
      "category": "Array Manipulation",
      "signature": "roll(arr: NDArray, shift: number | number[], axis?: number | number[]): NDArray",
      "description": "Roll array elements along a given axis.",
      "content": "### roll\n\n`roll(arr: NDArray, shift: number | number[], axis?: number | number[]): NDArray`\n\nRoll array elements along a given axis.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `shift` (number | number[]) — Number of places to shift elements\n- `axis` (number | number[]) (optional) — Axis along which to roll (default: flatten, roll, reshape)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rot90",
      "module": null,
      "category": "Array Manipulation",
      "signature": "rot90(arr: NDArray, k: number, axes: [number, number]): NDArray",
      "description": "Rotate an array by 90 degrees in the plane specified by axes.",
      "content": "### rot90\n\n`rot90(arr: NDArray, k: number, axes: [number, number]): NDArray`\n\nRotate an array by 90 degrees in the plane specified by axes.\n\n**Parameters:**\n- `arr` (NDArray) — Array with at least 2 dimensions\n- `k` (number) — Number of times to rotate by 90 degrees (default: 1)\n- `axes` ([number, number]) — The two axes that define the plane of rotation (default: [0, 1])\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "row_stack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "row_stack(tup: NDArray[]): NDArray",
      "description": "Stack arrays in sequence vertically (row-wise). Equivalent to concatenation along the first axis after making 1-D arrays 2-D.",
      "content": "### row_stack\n\n`row_stack(tup: NDArray[]): NDArray`\n\nStack arrays in sequence vertically (row-wise). Equivalent to concatenation along the first axis after making 1-D arrays 2-D.\n\n**Parameters:**\n- `tup` (NDArray[]) — Sequence of arrays\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "select",
      "module": null,
      "category": "Array Manipulation",
      "signature": "select(condlist: NDArray[], choicelist: NDArray[], defaultValue: number): Promise<NDArray>",
      "description": "Return an array drawn from elements in choicelist, depending on conditions.",
      "content": "### select\n\n`select(condlist: NDArray[], choicelist: NDArray[], defaultValue: number): Promise<NDArray>`\n\nReturn an array drawn from elements in choicelist, depending on conditions.\n\n**Parameters:**\n- `condlist` (NDArray[]) — List of boolean arrays (conditions)\n- `choicelist` (NDArray[]) — List of arrays from which output elements are taken\n- `defaultValue` (number) — Value used when all conditions are False (default: 0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "split",
      "module": null,
      "category": "Array Manipulation",
      "signature": "split(arr: NDArray, indices_or_sections: number | number[], axis: number): NDArray[]",
      "description": "Split an array into multiple sub-arrays of equal size. Raises error if array cannot be split into equal sections.",
      "content": "### split\n\n`split(arr: NDArray, indices_or_sections: number | number[], axis: number): NDArray[]`\n\nSplit an array into multiple sub-arrays of equal size. Raises error if array cannot be split into equal sections.\n\n**Parameters:**\n- `arr` (NDArray) — Array to split\n- `indices_or_sections` (number | number[]) — Number of equal sections or split indices\n- `axis` (number) — Axis along which to split (default: 0)\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "stack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "stack(arrays: NDArray[], axis: number): NDArray",
      "description": "Join a sequence of arrays along a new axis.",
      "content": "### stack\n\n`stack(arrays: NDArray[], axis: number): NDArray`\n\nJoin a sequence of arrays along a new axis.\n\n**Parameters:**\n- `arrays` (NDArray[]) — Sequence of arrays with the same shape\n- `axis` (number) — The axis in the result along which to stack (default: 0)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "take",
      "module": null,
      "category": "Array Manipulation",
      "signature": "take(arr: NDArray, indices: NDArray, axis: number, mode: ClipMode): Promise<NDArray>",
      "description": "Take elements from an array along an axis.",
      "content": "### take\n\n`take(arr: NDArray, indices: NDArray, axis: number, mode: ClipMode): Promise<NDArray>`\n\nTake elements from an array along an axis.\n\n**Parameters:**\n- `arr` (NDArray) — Source array\n- `indices` (NDArray) — Array of indices to take\n- `axis` (number) — Axis along which to take (default: 0)\n- `mode` (ClipMode) — How to handle out-of-bounds indices (default: 'raise')\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "take_along_axis",
      "module": null,
      "category": "Array Manipulation",
      "signature": "take_along_axis(arr: NDArray, indicesArr: NDArray, axis: number): Promise<NDArray>",
      "description": "Take values from the input array by matching 1d index and data slices.",
      "content": "### take_along_axis\n\n`take_along_axis(arr: NDArray, indicesArr: NDArray, axis: number): Promise<NDArray>`\n\nTake values from the input array by matching 1d index and data slices.\n\n**Parameters:**\n- `arr` (NDArray) — Source array\n- `indicesArr` (NDArray)\n- `axis` (number) — The axis to take along\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "takeFlat",
      "module": null,
      "category": "Array Manipulation",
      "signature": "takeFlat(arr: NDArray, indices: NDArray, mode: ClipMode): Promise<NDArray>",
      "description": "Take elements from a flattened array.",
      "content": "### takeFlat\n\n`takeFlat(arr: NDArray, indices: NDArray, mode: ClipMode): Promise<NDArray>`\n\nTake elements from a flattened array.\n\n**Parameters:**\n- `arr` (NDArray) — Source array (will be flattened conceptually)\n- `indices` (NDArray) — Array of flat indices\n- `mode` (ClipMode) — How to handle out-of-bounds indices (default: 'raise')\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "tile",
      "module": null,
      "category": "Array Manipulation",
      "signature": "tile(arr: NDArray, reps: number | number[]): Promise<NDArray>",
      "description": "Construct an array by repeating arr the number of times given by reps.",
      "content": "### tile\n\n`tile(arr: NDArray, reps: number | number[]): Promise<NDArray>`\n\nConstruct an array by repeating arr the number of times given by reps.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n- `reps` (number | number[]) — Number of repetitions along each axis\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "trim_zeros",
      "module": null,
      "category": "Array Manipulation",
      "signature": "trim_zeros(arr: NDArray, trim: string): NDArray",
      "description": "Trim the leading and/or trailing zeros from a 1-D array.",
      "content": "### trim_zeros\n\n`trim_zeros(arr: NDArray, trim: string): NDArray`\n\nTrim the leading and/or trailing zeros from a 1-D array.\n\n**Parameters:**\n- `arr` (NDArray) — Input 1-D array\n- `trim` (string) — 'f' for front, 'b' for back, 'fb' for both (default: 'fb')\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "unique",
      "module": null,
      "category": "Array Manipulation",
      "signature": "unique(arr: NDArray, options: UniqueOptions): Promise<NDArray | UniqueResult>",
      "description": "Find the unique elements of an array.",
      "content": "### unique\n\n`unique(arr: NDArray, options: UniqueOptions): Promise<NDArray | UniqueResult>`\n\nFind the unique elements of an array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array (will be flattened)\n- `options` (UniqueOptions) — Configuration options\n\n**Returns:** `Promise<NDArray | UniqueResult>`\n"
    },
    {
      "name": "uniqueAll",
      "module": null,
      "category": "Array Manipulation",
      "signature": "uniqueAll(arr: NDArray): Promise<UniqueResult>",
      "description": "Return unique values, indices, inverse, and counts.",
      "content": "### uniqueAll\n\n`uniqueAll(arr: NDArray): Promise<UniqueResult>`\n\nReturn unique values, indices, inverse, and counts.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<UniqueResult>`\n"
    },
    {
      "name": "uniqueCounts",
      "module": null,
      "category": "Array Manipulation",
      "signature": "uniqueCounts(arr: NDArray): Promise<object>",
      "description": "Return unique values and their counts.",
      "content": "### uniqueCounts\n\n`uniqueCounts(arr: NDArray): Promise<object>`\n\nReturn unique values and their counts.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<object>`\n"
    },
    {
      "name": "uniqueIndex",
      "module": null,
      "category": "Array Manipulation",
      "signature": "uniqueIndex(arr: NDArray): Promise<object>",
      "description": "Return unique values and indices of first occurrence.",
      "content": "### uniqueIndex\n\n`uniqueIndex(arr: NDArray): Promise<object>`\n\nReturn unique values and indices of first occurrence.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<object>`\n"
    },
    {
      "name": "uniqueInverse",
      "module": null,
      "category": "Array Manipulation",
      "signature": "uniqueInverse(arr: NDArray): Promise<object>",
      "description": "Return unique values and indices to reconstruct original.",
      "content": "### uniqueInverse\n\n`uniqueInverse(arr: NDArray): Promise<object>`\n\nReturn unique values and indices to reconstruct original.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<object>`\n"
    },
    {
      "name": "uniqueValues",
      "module": null,
      "category": "Array Manipulation",
      "signature": "uniqueValues(arr: NDArray): Promise<NDArray>",
      "description": "Return only the unique values (simplified interface).",
      "content": "### uniqueValues\n\n`uniqueValues(arr: NDArray): Promise<NDArray>`\n\nReturn only the unique values (simplified interface).\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "unstack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "unstack(arr: NDArray, axis: number): NDArray[]",
      "description": "Unpack the array along a given axis. The inverse of stack.",
      "content": "### unstack\n\n`unstack(arr: NDArray, axis: number): NDArray[]`\n\nUnpack the array along a given axis. The inverse of stack.\n\n**Parameters:**\n- `arr` (NDArray) — Array to unpack\n- `axis` (number) — Axis along which to unpack (default: 0)\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "vsplit",
      "module": null,
      "category": "Array Manipulation",
      "signature": "vsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]",
      "description": "Split an array into multiple sub-arrays vertically (row-wise).",
      "content": "### vsplit\n\n`vsplit(arr: NDArray, indices_or_sections: number | number[]): NDArray[]`\n\nSplit an array into multiple sub-arrays vertically (row-wise).\n\n**Parameters:**\n- `arr` (NDArray) — Array with at least 2 dimensions\n- `indices_or_sections` (number | number[]) — Number of sections or split indices\n\n**Returns:** `NDArray[]`\n"
    },
    {
      "name": "vstack",
      "module": null,
      "category": "Array Manipulation",
      "signature": "vstack(tup: NDArray[]): NDArray",
      "description": "Stack arrays in sequence vertically (row-wise). Equivalent to concatenation along the first axis after making 1-D arrays 2-D.",
      "content": "### vstack\n\n`vstack(tup: NDArray[]): NDArray`\n\nStack arrays in sequence vertically (row-wise). Equivalent to concatenation along the first axis after making 1-D arrays 2-D.\n\n**Parameters:**\n- `tup` (NDArray[]) — Sequence of arrays\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "Slice",
      "module": null,
      "category": "Indexing",
      "signature": "class Slice",
      "description": "Represents a slice with start:stop:step semantics. Mirrors Python's slice object behavior.",
      "content": "### Slice\n\n`class Slice`\n\nRepresents a slice with start:stop:step semantics. Mirrors Python's slice object behavior.\n\n**Properties:**\n- `start`: `null | number`\n- `step`: `null | number`\n- `stop`: `null | number`\n\n**Methods:**\n- `indices(length: number): [number, number, number, number]` — Compute concrete indices for a dimension of given length. Implements the same logic as Python's slice.indices().\n- `toString(): string` — String representation for debugging\n"
    },
    {
      "name": "argwhere",
      "module": null,
      "category": "Indexing",
      "signature": "argwhere(arr: NDArray): Promise<NDArray>",
      "description": "Find the indices of array elements that are non-zero, grouped by element.",
      "content": "### argwhere\n\n`argwhere(arr: NDArray): Promise<NDArray>`\n\nFind the indices of array elements that are non-zero, grouped by element.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "buildIndexSpecs",
      "module": null,
      "category": "Indexing",
      "signature": "buildIndexSpecs(indices: IndexElement[], shape: number[]): IndexSpec[]",
      "description": "Build IndexSpec array from parsed indices for C interop.",
      "content": "### buildIndexSpecs\n\n`buildIndexSpecs(indices: IndexElement[], shape: number[]): IndexSpec[]`\n\nBuild IndexSpec array from parsed indices for C interop.\n\n**Parameters:**\n- `indices` (IndexElement[]) — Expanded index elements (no ellipsis)\n- `shape` (number[]) — Shape of the array being indexed\n\n**Returns:** `IndexSpec[]`\n"
    },
    {
      "name": "expandEllipsis",
      "module": null,
      "category": "Indexing",
      "signature": "expandEllipsis(indices: IndexElement[], ndim: number): IndexElement[]",
      "description": "Expand ellipsis and validate index dimensions.",
      "content": "### expandEllipsis\n\n`expandEllipsis(indices: IndexElement[], ndim: number): IndexElement[]`\n\nExpand ellipsis and validate index dimensions.\n\n**Parameters:**\n- `indices` (IndexElement[]) — Array of index elements (may contain ellipsis)\n- `ndim` (number) — Number of dimensions in the array being indexed\n\n**Returns:** `IndexElement[]`\n"
    },
    {
      "name": "flatnonzero",
      "module": null,
      "category": "Indexing",
      "signature": "flatnonzero(arr: NDArray): Promise<NDArray>",
      "description": "Return flat indices of nonzero elements.",
      "content": "### flatnonzero\n\n`flatnonzero(arr: NDArray): Promise<NDArray>`\n\nReturn flat indices of nonzero elements.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "ndenumerate",
      "module": null,
      "category": "Indexing",
      "signature": "ndenumerate(arr: NDArray): Generator<[number[], number]>",
      "description": "Iterate over array with indices and values.",
      "content": "### ndenumerate\n\n`ndenumerate(arr: NDArray): Generator<[number[], number]>`\n\nIterate over array with indices and values.\n\n**Parameters:**\n- `arr` (NDArray) — Array to iterate\n\n**Returns:** `Generator<[number[], number]>`\n"
    },
    {
      "name": "ndindex",
      "module": null,
      "category": "Indexing",
      "signature": "ndindex(...shape: number[]): Generator<number[]>",
      "description": "Generate all index combinations for a shape.",
      "content": "### ndindex\n\n`ndindex(...shape: number[]): Generator<number[]>`\n\nGenerate all index combinations for a shape.\n\n**Parameters:**\n- `shape` (number[]) (rest) — Dimensions\n\n**Returns:** `Generator<number[]>`\n"
    },
    {
      "name": "nditer",
      "module": null,
      "category": "Indexing",
      "signature": "nditer(arr: NDArray): Generator<number>",
      "description": "Iterate over array elements.",
      "content": "### nditer\n\n`nditer(arr: NDArray): Generator<number>`\n\nIterate over array elements.\n\n**Parameters:**\n- `arr` (NDArray) — Array to iterate\n\n**Returns:** `Generator<number>`\n"
    },
    {
      "name": "nonzero",
      "module": null,
      "category": "Indexing",
      "signature": "nonzero(arr: NDArray): Promise<NDArray>",
      "description": "Find indices of nonzero elements.  Returns a 2D array of shape (num_nonzero, ndim) where each row contains the multi-dimensional index of a nonzero element.",
      "content": "### nonzero\n\n`nonzero(arr: NDArray): Promise<NDArray>`\n\nFind indices of nonzero elements.  Returns a 2D array of shape (num_nonzero, ndim) where each row contains the multi-dimensional index of a nonzero element.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "ravelMultiIndex",
      "module": null,
      "category": "Indexing",
      "signature": "ravelMultiIndex(coords: number[][], shape: number[]): Promise<number[]>",
      "description": "Convert a tuple of coordinate arrays into flat indices.",
      "content": "### ravelMultiIndex\n\n`ravelMultiIndex(coords: number[][], shape: number[]): Promise<number[]>`\n\nConvert a tuple of coordinate arrays into flat indices.\n\n**Parameters:**\n- `coords` (number[][]) — Array of coordinate arrays, one per dimension\n- `shape` (number[]) — Shape of the array\n\n**Returns:** `Promise<number[]>`\n"
    },
    {
      "name": "slice",
      "module": null,
      "category": "Indexing",
      "signature": "slice(start: null | number, stop: null | number, step: null | number): Slice",
      "description": "Factory function for creating slices with cleaner syntax.",
      "content": "### slice\n\n`slice(start: null | number, stop: null | number, step: null | number): Slice`\n\nFactory function for creating slices with cleaner syntax.\n\n**Parameters:**\n- `start` (null | number) — Start index (null for default)\n- `stop` (null | number) — Stop index (null for default)\n- `step` (null | number) — Step size (null for 1)\n\n**Returns:** `Slice`\n"
    },
    {
      "name": "unravelIndex",
      "module": null,
      "category": "Indexing",
      "signature": "unravelIndex(indices: NDArray | number[], shape: number[]): Promise<number[][]>",
      "description": "Convert a flat index into a tuple of coordinate arrays.",
      "content": "### unravelIndex\n\n`unravelIndex(indices: NDArray | number[], shape: number[]): Promise<number[][]>`\n\nConvert a flat index into a tuple of coordinate arrays.\n\n**Parameters:**\n- `indices` (NDArray | number[]) — Array of flat indices\n- `shape` (number[]) — Shape of the array\n\n**Returns:** `Promise<number[][]>`\n"
    },
    {
      "name": "abs",
      "module": null,
      "category": "Math",
      "signature": "abs(x: NDArray): NDArray",
      "description": "Alias for absolute.",
      "content": "### abs\n\n`abs(x: NDArray): NDArray`\n\nAlias for absolute.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "absolute",
      "module": null,
      "category": "Math",
      "signature": "absolute(x: NDArray): NDArray",
      "description": "Calculate the absolute value element-wise.",
      "content": "### absolute\n\n`absolute(x: NDArray): NDArray`\n\nCalculate the absolute value element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "add",
      "module": null,
      "category": "Math",
      "signature": "add(x1: NDArray, x2: NDArray): NDArray",
      "description": "Add arguments element-wise.",
      "content": "### add\n\n`add(x1: NDArray, x2: NDArray): NDArray`\n\nAdd arguments element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arccos",
      "module": null,
      "category": "Math",
      "signature": "arccos(x: NDArray): NDArray",
      "description": "Trigonometric inverse cosine, element-wise.",
      "content": "### arccos\n\n`arccos(x: NDArray): NDArray`\n\nTrigonometric inverse cosine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arccosh",
      "module": null,
      "category": "Math",
      "signature": "arccosh(x: NDArray): NDArray",
      "description": "Inverse hyperbolic cosine, element-wise.",
      "content": "### arccosh\n\n`arccosh(x: NDArray): NDArray`\n\nInverse hyperbolic cosine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arcsin",
      "module": null,
      "category": "Math",
      "signature": "arcsin(x: NDArray): NDArray",
      "description": "Inverse sine, element-wise.",
      "content": "### arcsin\n\n`arcsin(x: NDArray): NDArray`\n\nInverse sine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arcsinh",
      "module": null,
      "category": "Math",
      "signature": "arcsinh(x: NDArray): NDArray",
      "description": "Inverse hyperbolic sine element-wise.",
      "content": "### arcsinh\n\n`arcsinh(x: NDArray): NDArray`\n\nInverse hyperbolic sine element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arctan",
      "module": null,
      "category": "Math",
      "signature": "arctan(x: NDArray): NDArray",
      "description": "Trigonometric inverse tangent, element-wise.",
      "content": "### arctan\n\n`arctan(x: NDArray): NDArray`\n\nTrigonometric inverse tangent, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arctan2",
      "module": null,
      "category": "Math",
      "signature": "arctan2(x1: NDArray, x2: NDArray): NDArray",
      "description": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly.",
      "content": "### arctan2\n\n`arctan2(x1: NDArray, x2: NDArray): NDArray`\n\nElement-wise arc tangent of x1/x2 choosing the quadrant correctly.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "arctanh",
      "module": null,
      "category": "Math",
      "signature": "arctanh(x: NDArray): NDArray",
      "description": "Inverse hyperbolic tangent element-wise.",
      "content": "### arctanh\n\n`arctanh(x: NDArray): NDArray`\n\nInverse hyperbolic tangent element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "cbrt",
      "module": null,
      "category": "Math",
      "signature": "cbrt(x: NDArray): NDArray",
      "description": "Return the cube-root of an array, element-wise.",
      "content": "### cbrt\n\n`cbrt(x: NDArray): NDArray`\n\nReturn the cube-root of an array, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ceil",
      "module": null,
      "category": "Math",
      "signature": "ceil(x: NDArray): NDArray",
      "description": "Return the ceiling of the input, element-wise.",
      "content": "### ceil\n\n`ceil(x: NDArray): NDArray`\n\nReturn the ceiling of the input, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "copysign",
      "module": null,
      "category": "Math",
      "signature": "copysign(x1: NDArray, x2: NDArray): NDArray",
      "description": "Change the sign of x1 to that of x2, element-wise.",
      "content": "### copysign\n\n`copysign(x1: NDArray, x2: NDArray): NDArray`\n\nChange the sign of x1 to that of x2, element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "cos",
      "module": null,
      "category": "Math",
      "signature": "cos(x: NDArray): NDArray",
      "description": "Cosine element-wise.",
      "content": "### cos\n\n`cos(x: NDArray): NDArray`\n\nCosine element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "cosh",
      "module": null,
      "category": "Math",
      "signature": "cosh(x: NDArray): NDArray",
      "description": "Hyperbolic cosine, element-wise.",
      "content": "### cosh\n\n`cosh(x: NDArray): NDArray`\n\nHyperbolic cosine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "deg2rad",
      "module": null,
      "category": "Math",
      "signature": "deg2rad(x: NDArray): NDArray",
      "description": "Alias for radians.",
      "content": "### deg2rad\n\n`deg2rad(x: NDArray): NDArray`\n\nAlias for radians.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "degrees",
      "module": null,
      "category": "Math",
      "signature": "degrees(x: NDArray): NDArray",
      "description": "Convert angles from radians to degrees.",
      "content": "### degrees\n\n`degrees(x: NDArray): NDArray`\n\nConvert angles from radians to degrees.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "divide",
      "module": null,
      "category": "Math",
      "signature": "divide(x1: NDArray, x2: NDArray): NDArray",
      "description": "Divide arguments element-wise (true division).",
      "content": "### divide\n\n`divide(x1: NDArray, x2: NDArray): NDArray`\n\nDivide arguments element-wise (true division).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "divmod",
      "module": null,
      "category": "Math",
      "signature": "divmod(x1: NDArray, x2: NDArray): [NDArray, NDArray]",
      "description": "Return element-wise quotient and remainder simultaneously. Equivalent to (floor_divide(x1, x2), remainder(x1, x2)), but returns both in one call.",
      "content": "### divmod\n\n`divmod(x1: NDArray, x2: NDArray): [NDArray, NDArray]`\n\nReturn element-wise quotient and remainder simultaneously. Equivalent to (floor_divide(x1, x2), remainder(x1, x2)), but returns both in one call.\n\n**Parameters:**\n- `x1` (NDArray) — Dividend array\n- `x2` (NDArray) — Divisor array\n\n**Returns:** `[NDArray, NDArray]`\n"
    },
    {
      "name": "exp",
      "module": null,
      "category": "Math",
      "signature": "exp(x: NDArray): NDArray",
      "description": "Calculate the exponential of all elements in the input array.",
      "content": "### exp\n\n`exp(x: NDArray): NDArray`\n\nCalculate the exponential of all elements in the input array.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "exp2",
      "module": null,
      "category": "Math",
      "signature": "exp2(x: NDArray): NDArray",
      "description": "Calculate 2**x for all elements in the array.",
      "content": "### exp2\n\n`exp2(x: NDArray): NDArray`\n\nCalculate 2**x for all elements in the array.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "expm1",
      "module": null,
      "category": "Math",
      "signature": "expm1(x: NDArray): NDArray",
      "description": "Calculate exp(x) - 1 for all elements in the array.",
      "content": "### expm1\n\n`expm1(x: NDArray): NDArray`\n\nCalculate exp(x) - 1 for all elements in the array.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "floor",
      "module": null,
      "category": "Math",
      "signature": "floor(x: NDArray): NDArray",
      "description": "Return the floor of the input, element-wise.",
      "content": "### floor\n\n`floor(x: NDArray): NDArray`\n\nReturn the floor of the input, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "floor_divide",
      "module": null,
      "category": "Math",
      "signature": "floor_divide(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return the largest integer smaller or equal to the division of the inputs.",
      "content": "### floor_divide\n\n`floor_divide(x1: NDArray, x2: NDArray): NDArray`\n\nReturn the largest integer smaller or equal to the division of the inputs.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fmax",
      "module": null,
      "category": "Math",
      "signature": "fmax(x1: NDArray, x2: NDArray): NDArray",
      "description": "Element-wise maximum (ignores NaN).",
      "content": "### fmax\n\n`fmax(x1: NDArray, x2: NDArray): NDArray`\n\nElement-wise maximum (ignores NaN).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fmin",
      "module": null,
      "category": "Math",
      "signature": "fmin(x1: NDArray, x2: NDArray): NDArray",
      "description": "Element-wise minimum (ignores NaN).",
      "content": "### fmin\n\n`fmin(x1: NDArray, x2: NDArray): NDArray`\n\nElement-wise minimum (ignores NaN).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "fmod",
      "module": null,
      "category": "Math",
      "signature": "fmod(x1: NDArray, x2: NDArray): NDArray",
      "description": "Returns element-wise remainder of floor_divide (C-style modulo).",
      "content": "### fmod\n\n`fmod(x1: NDArray, x2: NDArray): NDArray`\n\nReturns element-wise remainder of floor_divide (C-style modulo).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "frexp",
      "module": null,
      "category": "Math",
      "signature": "frexp(x: NDArray): [NDArray, NDArray]",
      "description": "Decompose the elements of x into mantissa and twos exponent. Returns (mantissa, exponent), where x = mantissa * 2^exponent. The mantissa lies in the open-closed interval (-1, 1) for float64, and the twos exponent is a signed integer.",
      "content": "### frexp\n\n`frexp(x: NDArray): [NDArray, NDArray]`\n\nDecompose the elements of x into mantissa and twos exponent. Returns (mantissa, exponent), where x = mantissa * 2^exponent. The mantissa lies in the open-closed interval (-1, 1) for float64, and the twos exponent is a signed integer.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `[NDArray, NDArray]`\n"
    },
    {
      "name": "gcd",
      "module": null,
      "category": "Math",
      "signature": "gcd(x1: NDArray, x2: NDArray): NDArray",
      "description": "Returns the greatest common divisor of |x1| and |x2|. Input arrays must be integers.",
      "content": "### gcd\n\n`gcd(x1: NDArray, x2: NDArray): NDArray`\n\nReturns the greatest common divisor of |x1| and |x2|. Input arrays must be integers.\n\n**Parameters:**\n- `x1` (NDArray) — First array of integers\n- `x2` (NDArray) — Second array of integers\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "heaviside",
      "module": null,
      "category": "Math",
      "signature": "heaviside(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the Heaviside step function.  H(x) = 0 if x < 0 H(x) = h0 if x == 0 H(x) = 1 if x > 0",
      "content": "### heaviside\n\n`heaviside(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the Heaviside step function.  H(x) = 0 if x < 0 H(x) = h0 if x == 0 H(x) = 1 if x > 0\n\n**Parameters:**\n- `x1` (NDArray) — Input values\n- `x2` (NDArray) — Value of the function at x1 == 0 (h0)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "hypot",
      "module": null,
      "category": "Math",
      "signature": "hypot(x1: NDArray, x2: NDArray): NDArray",
      "description": "Given the \"legs\" of a right triangle, return its hypotenuse.",
      "content": "### hypot\n\n`hypot(x1: NDArray, x2: NDArray): NDArray`\n\nGiven the \"legs\" of a right triangle, return its hypotenuse.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "i0",
      "module": null,
      "category": "Math",
      "signature": "i0(x: number | NDArray | number[]): Promise<NDArray>",
      "description": "Modified Bessel function of the first kind, order 0.  Usually denoted I₀. This implementation uses Chebyshev polynomial approximations from the Cephes library, partitioning the domain into [0, 8] and (8, ∞).",
      "content": "### i0\n\n`i0(x: number | NDArray | number[]): Promise<NDArray>`\n\nModified Bessel function of the first kind, order 0.  Usually denoted I₀. This implementation uses Chebyshev polynomial approximations from the Cephes library, partitioning the domain into [0, 8] and (8, ∞).\n\n**Parameters:**\n- `x` (number | NDArray | number[]) — Input array, number, or array of numbers\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "lcm",
      "module": null,
      "category": "Math",
      "signature": "lcm(x1: NDArray, x2: NDArray): NDArray",
      "description": "Returns the lowest common multiple of |x1| and |x2|. Input arrays must be integers.",
      "content": "### lcm\n\n`lcm(x1: NDArray, x2: NDArray): NDArray`\n\nReturns the lowest common multiple of |x1| and |x2|. Input arrays must be integers.\n\n**Parameters:**\n- `x1` (NDArray) — First array of integers\n- `x2` (NDArray) — Second array of integers\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "ldexp",
      "module": null,
      "category": "Math",
      "signature": "ldexp(x1: NDArray, x2: NDArray): NDArray",
      "description": "Returns x1 * 2^x2, element-wise.  The mantissas x1 and twos exponents x2 are used to construct floating point numbers x = x1 * 2^x2.",
      "content": "### ldexp\n\n`ldexp(x1: NDArray, x2: NDArray): NDArray`\n\nReturns x1 * 2^x2, element-wise.  The mantissas x1 and twos exponents x2 are used to construct floating point numbers x = x1 * 2^x2.\n\n**Parameters:**\n- `x1` (NDArray) — Array of multipliers (mantissas)\n- `x2` (NDArray) — Array of twos exponents\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "log",
      "module": null,
      "category": "Math",
      "signature": "log(x: NDArray): NDArray",
      "description": "Natural logarithm, element-wise.",
      "content": "### log\n\n`log(x: NDArray): NDArray`\n\nNatural logarithm, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "log10",
      "module": null,
      "category": "Math",
      "signature": "log10(x: NDArray): NDArray",
      "description": "Base-10 logarithm, element-wise.",
      "content": "### log10\n\n`log10(x: NDArray): NDArray`\n\nBase-10 logarithm, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "log1p",
      "module": null,
      "category": "Math",
      "signature": "log1p(x: NDArray): NDArray",
      "description": "Return the natural logarithm of one plus the input array, element-wise.",
      "content": "### log1p\n\n`log1p(x: NDArray): NDArray`\n\nReturn the natural logarithm of one plus the input array, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "log2",
      "module": null,
      "category": "Math",
      "signature": "log2(x: NDArray): NDArray",
      "description": "Base-2 logarithm of x.",
      "content": "### log2\n\n`log2(x: NDArray): NDArray`\n\nBase-2 logarithm of x.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "logaddexp",
      "module": null,
      "category": "Math",
      "signature": "logaddexp(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the logarithm of the sum of exponentials of the inputs.",
      "content": "### logaddexp\n\n`logaddexp(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the logarithm of the sum of exponentials of the inputs.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "logaddexp2",
      "module": null,
      "category": "Math",
      "signature": "logaddexp2(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute log(2**x1 + 2**x2).",
      "content": "### logaddexp2\n\n`logaddexp2(x1: NDArray, x2: NDArray): NDArray`\n\nCompute log(2**x1 + 2**x2).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "maximum",
      "module": null,
      "category": "Math",
      "signature": "maximum(x1: NDArray, x2: NDArray): NDArray",
      "description": "Element-wise maximum of array elements (propagates NaN).",
      "content": "### maximum\n\n`maximum(x1: NDArray, x2: NDArray): NDArray`\n\nElement-wise maximum of array elements (propagates NaN).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "minimum",
      "module": null,
      "category": "Math",
      "signature": "minimum(x1: NDArray, x2: NDArray): NDArray",
      "description": "Element-wise minimum of array elements (propagates NaN).",
      "content": "### minimum\n\n`minimum(x1: NDArray, x2: NDArray): NDArray`\n\nElement-wise minimum of array elements (propagates NaN).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "mod",
      "module": null,
      "category": "Math",
      "signature": "mod(x1: NDArray, x2: NDArray): NDArray",
      "description": "Alias for remainder.",
      "content": "### mod\n\n`mod(x1: NDArray, x2: NDArray): NDArray`\n\nAlias for remainder.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "modf",
      "module": null,
      "category": "Math",
      "signature": "modf(x: NDArray): [NDArray, NDArray]",
      "description": "Return the fractional and integral parts of an array, element-wise. The fractional and integral parts are negative if the given number is negative.",
      "content": "### modf\n\n`modf(x: NDArray): [NDArray, NDArray]`\n\nReturn the fractional and integral parts of an array, element-wise. The fractional and integral parts are negative if the given number is negative.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `[NDArray, NDArray]`\n"
    },
    {
      "name": "multiply",
      "module": null,
      "category": "Math",
      "signature": "multiply(x1: NDArray, x2: NDArray): NDArray",
      "description": "Multiply arguments element-wise.",
      "content": "### multiply\n\n`multiply(x1: NDArray, x2: NDArray): NDArray`\n\nMultiply arguments element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "nan_to_num",
      "module": null,
      "category": "Math",
      "signature": "nan_to_num(x: NDArray, nan: number, posinf: null | number, neginf: null | number): Promise<NDArray>",
      "description": "Replace NaN with zero and infinity with large finite numbers.",
      "content": "### nan_to_num\n\n`nan_to_num(x: NDArray, nan: number, posinf: null | number, neginf: null | number): Promise<NDArray>`\n\nReplace NaN with zero and infinity with large finite numbers.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n- `nan` (number) — Value to replace NaN with (default: 0.0)\n- `posinf` (null | number) — Value to replace positive infinity with (default: largest finite float)\n- `neginf` (null | number) — Value to replace negative infinity with (default: most negative finite float)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "negative",
      "module": null,
      "category": "Math",
      "signature": "negative(x: NDArray): NDArray",
      "description": "Numerical negative, element-wise.",
      "content": "### negative\n\n`negative(x: NDArray): NDArray`\n\nNumerical negative, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "nextafter",
      "module": null,
      "category": "Math",
      "signature": "nextafter(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return the next floating-point value after x1 towards x2, element-wise.",
      "content": "### nextafter\n\n`nextafter(x1: NDArray, x2: NDArray): NDArray`\n\nReturn the next floating-point value after x1 towards x2, element-wise.\n\n**Parameters:**\n- `x1` (NDArray) — Starting values\n- `x2` (NDArray) — Direction values\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "positive",
      "module": null,
      "category": "Math",
      "signature": "positive(x: NDArray): NDArray",
      "description": "Numerical positive (returns a copy).",
      "content": "### positive\n\n`positive(x: NDArray): NDArray`\n\nNumerical positive (returns a copy).\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "power",
      "module": null,
      "category": "Math",
      "signature": "power(x1: NDArray, x2: NDArray): NDArray",
      "description": "First array elements raised to powers from second array, element-wise.",
      "content": "### power\n\n`power(x1: NDArray, x2: NDArray): NDArray`\n\nFirst array elements raised to powers from second array, element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rad2deg",
      "module": null,
      "category": "Math",
      "signature": "rad2deg(x: NDArray): NDArray",
      "description": "Alias for degrees.",
      "content": "### rad2deg\n\n`rad2deg(x: NDArray): NDArray`\n\nAlias for degrees.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "radians",
      "module": null,
      "category": "Math",
      "signature": "radians(x: NDArray): NDArray",
      "description": "Convert angles from degrees to radians.",
      "content": "### radians\n\n`radians(x: NDArray): NDArray`\n\nConvert angles from degrees to radians.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "reciprocal",
      "module": null,
      "category": "Math",
      "signature": "reciprocal(x: NDArray): NDArray",
      "description": "Return the reciprocal of the argument, element-wise.",
      "content": "### reciprocal\n\n`reciprocal(x: NDArray): NDArray`\n\nReturn the reciprocal of the argument, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "remainder",
      "module": null,
      "category": "Math",
      "signature": "remainder(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return element-wise remainder of division (Python-style modulo).",
      "content": "### remainder\n\n`remainder(x1: NDArray, x2: NDArray): NDArray`\n\nReturn element-wise remainder of division (Python-style modulo).\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "rint",
      "module": null,
      "category": "Math",
      "signature": "rint(x: NDArray): NDArray",
      "description": "Round elements of the array to the nearest integer.",
      "content": "### rint\n\n`rint(x: NDArray): NDArray`\n\nRound elements of the array to the nearest integer.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "round",
      "module": null,
      "category": "Math",
      "signature": "round(x: NDArray): NDArray",
      "description": "Round to nearest even value (banker's rounding).",
      "content": "### round\n\n`round(x: NDArray): NDArray`\n\nRound to nearest even value (banker's rounding).\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "sign",
      "module": null,
      "category": "Math",
      "signature": "sign(x: NDArray): NDArray",
      "description": "Returns element-wise sign: -1, 0, or +1.",
      "content": "### sign\n\n`sign(x: NDArray): NDArray`\n\nReturns element-wise sign: -1, 0, or +1.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "signbit",
      "module": null,
      "category": "Math",
      "signature": "signbit(x: NDArray): NDArray",
      "description": "Return element-wise True where signbit is set (less than zero).",
      "content": "### signbit\n\n`signbit(x: NDArray): NDArray`\n\nReturn element-wise True where signbit is set (less than zero).\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "sin",
      "module": null,
      "category": "Math",
      "signature": "sin(x: NDArray): NDArray",
      "description": "Trigonometric sine, element-wise.",
      "content": "### sin\n\n`sin(x: NDArray): NDArray`\n\nTrigonometric sine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "sinc",
      "module": null,
      "category": "Math",
      "signature": "sinc(x: NDArray): NDArray",
      "description": "Return the normalized sinc function: sin(pi*x) / (pi*x). The sinc function is used in various signal processing applications.",
      "content": "### sinc\n\n`sinc(x: NDArray): NDArray`\n\nReturn the normalized sinc function: sin(pi*x) / (pi*x). The sinc function is used in various signal processing applications.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "sinh",
      "module": null,
      "category": "Math",
      "signature": "sinh(x: NDArray): NDArray",
      "description": "Hyperbolic sine, element-wise.",
      "content": "### sinh\n\n`sinh(x: NDArray): NDArray`\n\nHyperbolic sine, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "spacing",
      "module": null,
      "category": "Math",
      "signature": "spacing(x: NDArray): NDArray",
      "description": "Return the distance between x and the nearest adjacent number. This is effectively the ulp (unit in the last place) of x.",
      "content": "### spacing\n\n`spacing(x: NDArray): NDArray`\n\nReturn the distance between x and the nearest adjacent number. This is effectively the ulp (unit in the last place) of x.\n\n**Parameters:**\n- `x` (NDArray) — Input values\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "sqrt",
      "module": null,
      "category": "Math",
      "signature": "sqrt(x: NDArray): NDArray",
      "description": "Return the non-negative square-root of an array, element-wise.",
      "content": "### sqrt\n\n`sqrt(x: NDArray): NDArray`\n\nReturn the non-negative square-root of an array, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "square",
      "module": null,
      "category": "Math",
      "signature": "square(x: NDArray): NDArray",
      "description": "Return the element-wise square of the input.",
      "content": "### square\n\n`square(x: NDArray): NDArray`\n\nReturn the element-wise square of the input.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "subtract",
      "module": null,
      "category": "Math",
      "signature": "subtract(x1: NDArray, x2: NDArray): NDArray",
      "description": "Subtract arguments, element-wise.",
      "content": "### subtract\n\n`subtract(x1: NDArray, x2: NDArray): NDArray`\n\nSubtract arguments, element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "tan",
      "module": null,
      "category": "Math",
      "signature": "tan(x: NDArray): NDArray",
      "description": "Compute tangent element-wise.",
      "content": "### tan\n\n`tan(x: NDArray): NDArray`\n\nCompute tangent element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "tanh",
      "module": null,
      "category": "Math",
      "signature": "tanh(x: NDArray): NDArray",
      "description": "Compute hyperbolic tangent element-wise.",
      "content": "### tanh\n\n`tanh(x: NDArray): NDArray`\n\nCompute hyperbolic tangent element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "true_divide",
      "module": null,
      "category": "Math",
      "signature": "true_divide(x1: NDArray, x2: NDArray): NDArray",
      "description": "Alias for divide.",
      "content": "### true_divide\n\n`true_divide(x1: NDArray, x2: NDArray): NDArray`\n\nAlias for divide.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "trunc",
      "module": null,
      "category": "Math",
      "signature": "trunc(x: NDArray): NDArray",
      "description": "Return the truncated value of the input, element-wise.",
      "content": "### trunc\n\n`trunc(x: NDArray): NDArray`\n\nReturn the truncated value of the input, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "all",
      "module": null,
      "category": "Logic",
      "signature": "all(a: NDArray, axis?: number, keepdims: boolean): Promise<boolean | NDArray>",
      "description": "Test whether all array elements along a given axis evaluate to True.",
      "content": "### all\n\n`all(a: NDArray, axis?: number, keepdims: boolean): Promise<boolean | NDArray>`\n\nTest whether all array elements along a given axis evaluate to True.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (number) (optional) — Axis along which to test (undefined for entire array)\n- `keepdims` (boolean) — If true, keep reduced axis as size-1 dimension\n\n**Returns:** `Promise<boolean | NDArray>`\n"
    },
    {
      "name": "any",
      "module": null,
      "category": "Logic",
      "signature": "any(a: NDArray, axis?: number, keepdims: boolean): Promise<boolean | NDArray>",
      "description": "Test whether any array element along a given axis evaluates to True.",
      "content": "### any\n\n`any(a: NDArray, axis?: number, keepdims: boolean): Promise<boolean | NDArray>`\n\nTest whether any array element along a given axis evaluates to True.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (number) (optional) — Axis along which to test (undefined for entire array)\n- `keepdims` (boolean) — If true, keep reduced axis as size-1 dimension\n\n**Returns:** `Promise<boolean | NDArray>`\n"
    },
    {
      "name": "logical_and",
      "module": null,
      "category": "Logic",
      "signature": "logical_and(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the truth value of x1 AND x2 element-wise.",
      "content": "### logical_and\n\n`logical_and(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the truth value of x1 AND x2 element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "logical_not",
      "module": null,
      "category": "Logic",
      "signature": "logical_not(x: NDArray): NDArray",
      "description": "Compute the truth value of NOT x element-wise.",
      "content": "### logical_not\n\n`logical_not(x: NDArray): NDArray`\n\nCompute the truth value of NOT x element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "logical_or",
      "module": null,
      "category": "Logic",
      "signature": "logical_or(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the truth value of x1 OR x2 element-wise.",
      "content": "### logical_or\n\n`logical_or(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the truth value of x1 OR x2 element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "logical_xor",
      "module": null,
      "category": "Logic",
      "signature": "logical_xor(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the truth value of x1 XOR x2, element-wise.",
      "content": "### logical_xor\n\n`logical_xor(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the truth value of x1 XOR x2, element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "piecewise",
      "module": null,
      "category": "Logic",
      "signature": "piecewise(x: NDArray, condlist: NDArray[], funclist: number | object[], ...args: unknown[]): Promise<NDArray>",
      "description": "Evaluate a piecewise-defined function.  Given a set of conditions and corresponding functions, evaluate each function on the input only where its condition is true.",
      "content": "### piecewise\n\n`piecewise(x: NDArray, condlist: NDArray[], funclist: number | object[], ...args: unknown[]): Promise<NDArray>`\n\nEvaluate a piecewise-defined function.  Given a set of conditions and corresponding functions, evaluate each function on the input only where its condition is true.\n\n**Parameters:**\n- `x` (NDArray) — Input array (domain of the piecewise function)\n- `condlist` (NDArray[]) — List of boolean arrays defining conditions\n- `funclist` (number | object[]) — List of functions or constants for each condition.\n                  If funclist has one more element than condlist, the last\n                  element is used as the default (\"otherwise\") case.\n- `args` (unknown[]) (rest) — Additional arguments passed to all functions\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "where",
      "module": null,
      "category": "Logic",
      "signature": "where(condition: NDArray, x?: NDArray, y?: NDArray): Promise<NDArray>",
      "description": "Return elements chosen from x or y depending on condition.  If x and y are provided, returns an array where elements are taken from x where condition is true, and from y where condition is false.  If only condition is provided, returns the indices where condition is true (equivalent to nonzero).",
      "content": "### where\n\n`where(condition: NDArray, x?: NDArray, y?: NDArray): Promise<NDArray>`\n\nReturn elements chosen from x or y depending on condition.  If x and y are provided, returns an array where elements are taken from x where condition is true, and from y where condition is false.  If only condition is provided, returns the indices where condition is true (equivalent to nonzero).\n\n**Parameters:**\n- `condition` (NDArray) — Boolean condition array\n- `x` (NDArray) (optional) — Values where condition is true (optional)\n- `y` (NDArray) (optional) — Values where condition is false (optional)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "allclose",
      "module": null,
      "category": "Comparison",
      "signature": "allclose(a: NDArray, b: NDArray, rtol: number, atol: number, equal_nan: boolean): Promise<boolean>",
      "description": "Returns True if two arrays are element-wise equal within a tolerance.",
      "content": "### allclose\n\n`allclose(a: NDArray, b: NDArray, rtol: number, atol: number, equal_nan: boolean): Promise<boolean>`\n\nReturns True if two arrays are element-wise equal within a tolerance.\n\n**Parameters:**\n- `a` (NDArray) — First array\n- `b` (NDArray) — Second array\n- `rtol` (number) — Relative tolerance (default 1e-5)\n- `atol` (number) — Absolute tolerance (default 1e-8)\n- `equal_nan` (boolean) — Whether to compare NaN's as equal (default false)\n\n**Returns:** `Promise<boolean>`\n"
    },
    {
      "name": "array_equal",
      "module": null,
      "category": "Comparison",
      "signature": "array_equal(a1: NDArray, a2: NDArray, equal_nan: boolean): Promise<boolean>",
      "description": "True if two arrays have the same shape and elements, False otherwise.",
      "content": "### array_equal\n\n`array_equal(a1: NDArray, a2: NDArray, equal_nan: boolean): Promise<boolean>`\n\nTrue if two arrays have the same shape and elements, False otherwise.\n\n**Parameters:**\n- `a1` (NDArray) — First array\n- `a2` (NDArray) — Second array\n- `equal_nan` (boolean) — Whether to compare NaN's as equal (default false)\n\n**Returns:** `Promise<boolean>`\n"
    },
    {
      "name": "array_equiv",
      "module": null,
      "category": "Comparison",
      "signature": "array_equiv(a1: NDArray, a2: NDArray): Promise<boolean>",
      "description": "Returns True if input arrays are shape consistent and all elements equal.  Shape consistent means they are either the same shape, or one input array can be broadcast to create the same shape as the other one.",
      "content": "### array_equiv\n\n`array_equiv(a1: NDArray, a2: NDArray): Promise<boolean>`\n\nReturns True if input arrays are shape consistent and all elements equal.  Shape consistent means they are either the same shape, or one input array can be broadcast to create the same shape as the other one.\n\n**Parameters:**\n- `a1` (NDArray) — First array\n- `a2` (NDArray) — Second array\n\n**Returns:** `Promise<boolean>`\n"
    },
    {
      "name": "equal",
      "module": null,
      "category": "Comparison",
      "signature": "equal(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 == x2) element-wise.",
      "content": "### equal\n\n`equal(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 == x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "greater",
      "module": null,
      "category": "Comparison",
      "signature": "greater(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 > x2) element-wise.",
      "content": "### greater\n\n`greater(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 > x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "greater_equal",
      "module": null,
      "category": "Comparison",
      "signature": "greater_equal(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 >= x2) element-wise.",
      "content": "### greater_equal\n\n`greater_equal(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 >= x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "isclose",
      "module": null,
      "category": "Comparison",
      "signature": "isclose(a: NDArray, b: NDArray, rtol: number, atol: number, equal_nan: boolean): Promise<NDArray>",
      "description": "Returns a boolean array where two arrays are element-wise equal within tolerance.  Formula: |a - b| <= (atol + rtol * |b|)",
      "content": "### isclose\n\n`isclose(a: NDArray, b: NDArray, rtol: number, atol: number, equal_nan: boolean): Promise<NDArray>`\n\nReturns a boolean array where two arrays are element-wise equal within tolerance.  Formula: |a - b| <= (atol + rtol * |b|)\n\n**Parameters:**\n- `a` (NDArray) — First array\n- `b` (NDArray) — Second array (reference)\n- `rtol` (number) — Relative tolerance (default 1e-5)\n- `atol` (number) — Absolute tolerance (default 1e-8)\n- `equal_nan` (boolean) — Whether to compare NaN's as equal (default false)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "iscomplex",
      "module": null,
      "category": "Comparison",
      "signature": "iscomplex(x: NDArray): Promise<NDArray>",
      "description": "Returns a bool array where True if input element is complex (imaginary part != 0). For non-complex dtype arrays, returns all False.",
      "content": "### iscomplex\n\n`iscomplex(x: NDArray): Promise<NDArray>`\n\nReturns a bool array where True if input element is complex (imaginary part != 0). For non-complex dtype arrays, returns all False.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "iscomplexobj",
      "module": null,
      "category": "Comparison",
      "signature": "iscomplexobj(x: NDArray): boolean",
      "description": "Check if the array has a complex dtype.",
      "content": "### iscomplexobj\n\n`iscomplexobj(x: NDArray): boolean`\n\nCheck if the array has a complex dtype.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "isfinite",
      "module": null,
      "category": "Comparison",
      "signature": "isfinite(x: NDArray): Promise<NDArray>",
      "description": "Test element-wise for finiteness (not infinity and not NaN).",
      "content": "### isfinite\n\n`isfinite(x: NDArray): Promise<NDArray>`\n\nTest element-wise for finiteness (not infinity and not NaN).\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isfortran",
      "module": null,
      "category": "Comparison",
      "signature": "isfortran(a: NDArray): boolean",
      "description": "Check if the array is Fortran contiguous but not C contiguous.",
      "content": "### isfortran\n\n`isfortran(a: NDArray): boolean`\n\nCheck if the array is Fortran contiguous but not C contiguous.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "isinf",
      "module": null,
      "category": "Comparison",
      "signature": "isinf(x: NDArray): Promise<NDArray>",
      "description": "Test element-wise for positive or negative infinity.",
      "content": "### isinf\n\n`isinf(x: NDArray): Promise<NDArray>`\n\nTest element-wise for positive or negative infinity.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isnan",
      "module": null,
      "category": "Comparison",
      "signature": "isnan(x: NDArray): Promise<NDArray>",
      "description": "Test element-wise for NaN.",
      "content": "### isnan\n\n`isnan(x: NDArray): Promise<NDArray>`\n\nTest element-wise for NaN.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isneginf",
      "module": null,
      "category": "Comparison",
      "signature": "isneginf(x: NDArray): Promise<NDArray>",
      "description": "Test element-wise for negative infinity.",
      "content": "### isneginf\n\n`isneginf(x: NDArray): Promise<NDArray>`\n\nTest element-wise for negative infinity.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isposinf",
      "module": null,
      "category": "Comparison",
      "signature": "isposinf(x: NDArray): Promise<NDArray>",
      "description": "Test element-wise for positive infinity.",
      "content": "### isposinf\n\n`isposinf(x: NDArray): Promise<NDArray>`\n\nTest element-wise for positive infinity.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isreal",
      "module": null,
      "category": "Comparison",
      "signature": "isreal(x: NDArray): Promise<NDArray>",
      "description": "Returns a bool array where True if input element is real (imaginary part == 0). For non-complex dtype arrays, returns all True.",
      "content": "### isreal\n\n`isreal(x: NDArray): Promise<NDArray>`\n\nReturns a bool array where True if input element is real (imaginary part == 0). For non-complex dtype arrays, returns all True.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "isrealobj",
      "module": null,
      "category": "Comparison",
      "signature": "isrealobj(x: NDArray): boolean",
      "description": "Check if the array has a non-complex dtype.",
      "content": "### isrealobj\n\n`isrealobj(x: NDArray): boolean`\n\nCheck if the array has a non-complex dtype.\n\n**Parameters:**\n- `x` (NDArray) — Input array\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "isscalar",
      "module": null,
      "category": "Comparison",
      "signature": "isscalar(element: unknown): boolean",
      "description": "Check if an element is a scalar type.",
      "content": "### isscalar\n\n`isscalar(element: unknown): boolean`\n\nCheck if an element is a scalar type.\n\n**Parameters:**\n- `element` (unknown) — Value to check\n\n**Returns:** `boolean`\n"
    },
    {
      "name": "less",
      "module": null,
      "category": "Comparison",
      "signature": "less(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 < x2) element-wise.",
      "content": "### less\n\n`less(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 < x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "less_equal",
      "module": null,
      "category": "Comparison",
      "signature": "less_equal(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 <= x2) element-wise.",
      "content": "### less_equal\n\n`less_equal(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 <= x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "not_equal",
      "module": null,
      "category": "Comparison",
      "signature": "not_equal(x1: NDArray, x2: NDArray): NDArray",
      "description": "Return (x1 != x2) element-wise.",
      "content": "### not_equal\n\n`not_equal(x1: NDArray, x2: NDArray): NDArray`\n\nReturn (x1 != x2) element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "bincount",
      "module": null,
      "category": "Statistics",
      "signature": "bincount(x: NDArray | number[], weights: null | NDArray | number[], minlength: number): Promise<NDArray>",
      "description": "Count number of occurrences of each value in array of non-negative ints.",
      "content": "### bincount\n\n`bincount(x: NDArray | number[], weights: null | NDArray | number[], minlength: number): Promise<NDArray>`\n\nCount number of occurrences of each value in array of non-negative ints.\n\n**Parameters:**\n- `x` (NDArray | number[]) — Input array of non-negative integers\n- `weights` (null | NDArray | number[]) — Weights, array of the same shape as x (optional)\n- `minlength` (number) — Minimum number of bins for the output array (default: 0)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "cumprod",
      "module": null,
      "category": "Statistics",
      "signature": "cumprod(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>",
      "description": "Return the cumulative product of elements along a given axis.",
      "content": "### cumprod\n\n`cumprod(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>`\n\nReturn the cumulative product of elements along a given axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute cumprod. null = flatten first\n- `dtype` (DType) (optional) — Type of output array (default: promotes integers to float64)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "cumsum",
      "module": null,
      "category": "Statistics",
      "signature": "cumsum(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>",
      "description": "Return the cumulative sum of the elements along a given axis.",
      "content": "### cumsum\n\n`cumsum(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>`\n\nReturn the cumulative sum of the elements along a given axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute cumsum. null = flatten first\n- `dtype` (DType) (optional) — Type of output array (default: promotes integers to float64)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "digitize",
      "module": null,
      "category": "Statistics",
      "signature": "digitize(x: NDArray | number[], bins: NDArray | number[], right: boolean): Promise<NDArray>",
      "description": "Return the indices of the bins to which each value in input array belongs.",
      "content": "### digitize\n\n`digitize(x: NDArray | number[], bins: NDArray | number[], right: boolean): Promise<NDArray>`\n\nReturn the indices of the bins to which each value in input array belongs.\n\n**Parameters:**\n- `x` (NDArray | number[]) — Input array to be binned\n- `bins` (NDArray | number[]) — Array of bins. Must be 1-dimensional and monotonic.\n- `right` (boolean) — If true, bins[i-1] < x <= bins[i]. If false (default), bins[i-1] <= x < bins[i].\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "histogram",
      "module": null,
      "category": "Statistics",
      "signature": "histogram(a: NDArray | number[], bins: number | NDArray | number[] | BinMethod, range: null | [number, number], density: boolean, weights: null | NDArray | number[]): Promise<HistogramResult>",
      "description": "Compute the histogram of a dataset.",
      "content": "### histogram\n\n`histogram(a: NDArray | number[], bins: number | NDArray | number[] | BinMethod, range: null | [number, number], density: boolean, weights: null | NDArray | number[]): Promise<HistogramResult>`\n\nCompute the histogram of a dataset.\n\n**Parameters:**\n- `a` (NDArray | number[]) — Input data\n- `bins` (number | NDArray | number[] | BinMethod) — Number of bins, method string, or explicit bin edges (default: 10)\n- `range` (null | [number, number]) — Lower and upper range of bins\n- `density` (boolean) — If true, return probability density instead of counts (default: false)\n- `weights` (null | NDArray | number[]) — Weights for each data point\n\n**Returns:** `Promise<HistogramResult>`\n"
    },
    {
      "name": "histogram_bin_edges",
      "module": null,
      "category": "Statistics",
      "signature": "histogram_bin_edges(a: NDArray | number[], bins: number | NDArray | number[] | BinMethod, range: null | [number, number], weights: null | NDArray | number[]): Promise<NDArray>",
      "description": "Compute histogram bin edges.",
      "content": "### histogram_bin_edges\n\n`histogram_bin_edges(a: NDArray | number[], bins: number | NDArray | number[] | BinMethod, range: null | [number, number], weights: null | NDArray | number[]): Promise<NDArray>`\n\nCompute histogram bin edges.\n\n**Parameters:**\n- `a` (NDArray | number[]) — Input data\n- `bins` (number | NDArray | number[] | BinMethod) — Number of bins, bin method string, or explicit bin edges (default: 'auto')\n- `range` (null | [number, number]) — Lower and upper range of bins\n- `weights` (null | NDArray | number[]) — Weights (used for some bin estimation methods)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "histogram2d",
      "module": null,
      "category": "Statistics",
      "signature": "histogram2d(x: NDArray | number[], y: NDArray | number[], bins: number | [number, number] | [NDArray | number[], NDArray | number[]], range: null | [[number, number], [number, number]], density: boolean, weights: null | NDArray | number[]): Promise<Histogram2DResult>",
      "description": "Compute the bi-dimensional histogram of two data samples.",
      "content": "### histogram2d\n\n`histogram2d(x: NDArray | number[], y: NDArray | number[], bins: number | [number, number] | [NDArray | number[], NDArray | number[]], range: null | [[number, number], [number, number]], density: boolean, weights: null | NDArray | number[]): Promise<Histogram2DResult>`\n\nCompute the bi-dimensional histogram of two data samples.\n\n**Parameters:**\n- `x` (NDArray | number[]) — Array of x coordinates\n- `y` (NDArray | number[]) — Array of y coordinates\n- `bins` (number | [number, number] | [NDArray | number[], NDArray | number[]]) — Number of bins or [nx, ny] or [xedges, yedges] (default: 10)\n- `range` (null | [[number, number], [number, number]]) — [[xmin, xmax], [ymin, ymax]]\n- `density` (boolean) — If true, return probability density (default: false)\n- `weights` (null | NDArray | number[]) — Weights for each sample\n\n**Returns:** `Promise<Histogram2DResult>`\n"
    },
    {
      "name": "histogramdd",
      "module": null,
      "category": "Statistics",
      "signature": "histogramdd(sample: NDArray | number[] | number[][], bins: number | number[] | NDArray[], range: null | [number, number][], density: boolean, weights: null | NDArray | number[]): Promise<HistogramDDResult>",
      "description": "Compute the multidimensional histogram of some data.",
      "content": "### histogramdd\n\n`histogramdd(sample: NDArray | number[] | number[][], bins: number | number[] | NDArray[], range: null | [number, number][], density: boolean, weights: null | NDArray | number[]): Promise<HistogramDDResult>`\n\nCompute the multidimensional histogram of some data.\n\n**Parameters:**\n- `sample` (NDArray | number[] | number[][]) — Data to histogram (shape: [N, D] for N samples in D dimensions,\n                or 1D array for single dimension)\n- `bins` (number | number[] | NDArray[]) — Number of bins per dimension or list of bin edges (default: 10)\n- `range` (null | [number, number][]) — Ranges for each dimension [[min, max], ...]\n- `density` (boolean) — If true, return probability density (default: false)\n- `weights` (null | NDArray | number[]) — Weights for each sample\n\n**Returns:** `Promise<HistogramDDResult>`\n"
    },
    {
      "name": "max",
      "module": null,
      "category": "Statistics",
      "signature": "max(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return the maximum of an array or maximum along an axis.",
      "content": "### max\n\n`max(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn the maximum of an array or maximum along an axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to find maximum. null finds maximum of all elements.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "mean",
      "module": null,
      "category": "Statistics",
      "signature": "mean(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the arithmetic mean along the specified axis.",
      "content": "### mean\n\n`mean(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the arithmetic mean along the specified axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute mean. null computes mean of all elements.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n- `dtype` (DType) (optional) — Output dtype (default: float64 for integers, same as input otherwise)\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "median",
      "module": null,
      "category": "Statistics",
      "signature": "median(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the median along the specified axis.",
      "content": "### median\n\n`median(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nCompute the median along the specified axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute median. null computes median of all elements.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "min",
      "module": null,
      "category": "Statistics",
      "signature": "min(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return the minimum of an array or minimum along an axis.",
      "content": "### min\n\n`min(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn the minimum of an array or minimum along an axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to find minimum. null finds minimum of all elements.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanargmax",
      "module": null,
      "category": "Statistics",
      "signature": "nanargmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return the indices of the maximum values along an axis, ignoring NaNs.",
      "content": "### nanargmax\n\n`nanargmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn the indices of the maximum values along an axis, ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to operate (null = flattened array)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanargmin",
      "module": null,
      "category": "Statistics",
      "signature": "nanargmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return the indices of the minimum values along an axis, ignoring NaNs.",
      "content": "### nanargmin\n\n`nanargmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn the indices of the minimum values along an axis, ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to operate (null = flattened array)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nancumprod",
      "module": null,
      "category": "Statistics",
      "signature": "nancumprod(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>",
      "description": "Return the cumulative product of array elements treating NaNs as one.  The cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.",
      "content": "### nancumprod\n\n`nancumprod(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>`\n\nReturn the cumulative product of array elements treating NaNs as one.  The cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute. null = flatten first\n- `dtype` (DType) (optional) — Type of output array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "nancumsum",
      "module": null,
      "category": "Statistics",
      "signature": "nancumsum(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>",
      "description": "Return the cumulative sum of array elements treating NaNs as zero.  The cumulative sum does not change when NaNs are encountered and leading NaNs are replaced by zeros.",
      "content": "### nancumsum\n\n`nancumsum(a: NDArray, axis: null | number, dtype?: DType): Promise<NDArray>`\n\nReturn the cumulative sum of array elements treating NaNs as zero.  The cumulative sum does not change when NaNs are encountered and leading NaNs are replaced by zeros.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute. null = flatten first\n- `dtype` (DType) (optional) — Type of output array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "nanmax",
      "module": null,
      "category": "Statistics",
      "signature": "nanmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return maximum of an array or maximum along an axis, ignoring any NaNs.",
      "content": "### nanmax\n\n`nanmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn maximum of an array or maximum along an axis, ignoring any NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers\n- `axis` (null | number) — Axis or axes along which to operate (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanmean",
      "module": null,
      "category": "Statistics",
      "signature": "nanmean(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the arithmetic mean along the specified axis, ignoring NaNs.",
      "content": "### nanmean\n\n`nanmean(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the arithmetic mean along the specified axis, ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers whose mean is desired\n- `axis` (null | number) — Axis or axes along which the means are computed (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n- `dtype` (DType) (optional) — Type to use in computing the mean\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanmedian",
      "module": null,
      "category": "Statistics",
      "signature": "nanmedian(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the median along the specified axis, while ignoring NaNs.",
      "content": "### nanmedian\n\n`nanmedian(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nCompute the median along the specified axis, while ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis or axes along which the medians are computed (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanmin",
      "module": null,
      "category": "Statistics",
      "signature": "nanmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Return minimum of an array or minimum along an axis, ignoring any NaNs.",
      "content": "### nanmin\n\n`nanmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturn minimum of an array or minimum along an axis, ignoring any NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers\n- `axis` (null | number) — Axis or axes along which to operate (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanpercentile",
      "module": null,
      "category": "Statistics",
      "signature": "nanpercentile(a: NDArray, q: number | number[], axis: null | number, interpolation: \"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\", keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the q-th percentile of the data along the specified axis, while ignoring NaN values.",
      "content": "### nanpercentile\n\n`nanpercentile(a: NDArray, q: number | number[], axis: null | number, interpolation: \"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\", keepdims: boolean): Promise<number | NDArray>`\n\nCompute the q-th percentile of the data along the specified axis, while ignoring NaN values.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `q` (number | number[]) — Percentile(s) to compute, in range [0, 100]\n- `axis` (null | number) — Axis along which to compute (null = all elements)\n- `interpolation` (\"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\") — Interpolation method ('linear', 'lower', 'higher', 'midpoint', 'nearest')\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanprod",
      "module": null,
      "category": "Statistics",
      "signature": "nanprod(a: NDArray, axis: null | number, keepdims: boolean, _dtype?: DType): Promise<number | NDArray>",
      "description": "Return the product of array elements over a given axis treating NaNs as one.",
      "content": "### nanprod\n\n`nanprod(a: NDArray, axis: null | number, keepdims: boolean, _dtype?: DType): Promise<number | NDArray>`\n\nReturn the product of array elements over a given axis treating NaNs as one.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers whose product is desired\n- `axis` (null | number) — Axis or axes along which the product is computed (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n- `_dtype` (DType) (optional)\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanquantile",
      "module": null,
      "category": "Statistics",
      "signature": "nanquantile(a: NDArray, q: number | number[], axis: null | number, interpolation: \"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\", keepdims: boolean): Promise<number | NDArray>",
      "description": "Compute the q-th quantile of the data along the specified axis, while ignoring NaN values.",
      "content": "### nanquantile\n\n`nanquantile(a: NDArray, q: number | number[], axis: null | number, interpolation: \"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\", keepdims: boolean): Promise<number | NDArray>`\n\nCompute the q-th quantile of the data along the specified axis, while ignoring NaN values.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `q` (number | number[]) — Quantile(s) to compute, in range [0, 1]\n- `axis` (null | number) — Axis along which to compute (null = all elements)\n- `interpolation` (\"linear\" | \"lower\" | \"higher\" | \"midpoint\" | \"nearest\") — Interpolation method ('linear', 'lower', 'higher', 'midpoint', 'nearest')\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanstd",
      "module": null,
      "category": "Statistics",
      "signature": "nanstd(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the standard deviation along the specified axis, ignoring NaNs.",
      "content": "### nanstd\n\n`nanstd(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the standard deviation along the specified axis, ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers\n- `axis` (null | number) — Axis or axes along which the standard deviation is computed (null = all elements)\n- `ddof` (number) — Delta Degrees of Freedom (divisor is N - ddof)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n- `dtype` (DType) (optional) — Type to use in computing the standard deviation\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nansum",
      "module": null,
      "category": "Statistics",
      "signature": "nansum(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Return the sum of array elements over a given axis treating NaNs as zero.",
      "content": "### nansum\n\n`nansum(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nReturn the sum of array elements over a given axis treating NaNs as zero.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers whose sum is desired\n- `axis` (null | number) — Axis or axes along which the sum is computed (null = all elements)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n- `dtype` (DType) (optional) — The type of the returned array\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "nanvar",
      "module": null,
      "category": "Statistics",
      "signature": "nanvar(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the variance along the specified axis, while ignoring NaNs.",
      "content": "### nanvar\n\n`nanvar(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the variance along the specified axis, while ignoring NaNs.\n\n**Parameters:**\n- `a` (NDArray) — Array containing numbers\n- `axis` (null | number) — Axis or axes along which the variance is computed (null = all elements)\n- `ddof` (number) — Delta Degrees of Freedom (divisor is N - ddof)\n- `keepdims` (boolean) — If true, reduced axes are left with size one\n- `dtype` (DType) (optional) — Type to use in computing the variance\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "std",
      "module": null,
      "category": "Statistics",
      "signature": "std(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the standard deviation along the specified axis.",
      "content": "### std\n\n`std(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the standard deviation along the specified axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute std. null computes std of all elements.\n- `ddof` (number) — Delta Degrees of Freedom. Divisor is N - ddof. Default: 0\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n- `dtype` (DType) (optional) — Output dtype\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "sum",
      "module": null,
      "category": "Statistics",
      "signature": "sum(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Sum of array elements over a given axis.",
      "content": "### sum\n\n`sum(a: NDArray, axis: null | number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nSum of array elements over a given axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to sum. null sums all elements.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n- `dtype` (DType) (optional) — Output dtype (default: float64 for integers, same as input otherwise)\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "var_",
      "module": null,
      "category": "Statistics",
      "signature": "var_(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Alias for variance (matches NumPy's np.var)",
      "content": "### var_\n\n`var_(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nAlias for variance (matches NumPy's np.var)\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute variance. null computes variance of all elements.\n- `ddof` (number) — Delta Degrees of Freedom. Divisor is N - ddof. Default: 0 (population variance)\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n- `dtype` (DType) (optional) — Output dtype\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "variance",
      "module": null,
      "category": "Statistics",
      "signature": "variance(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>",
      "description": "Compute the variance along the specified axis.",
      "content": "### variance\n\n`variance(a: NDArray, axis: null | number, ddof: number, keepdims: boolean, dtype?: DType): Promise<number | NDArray>`\n\nCompute the variance along the specified axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to compute variance. null computes variance of all elements.\n- `ddof` (number) — Delta Degrees of Freedom. Divisor is N - ddof. Default: 0 (population variance)\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n- `dtype` (DType) (optional) — Output dtype\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "argmax",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "argmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Returns the indices of the maximum values along an axis.",
      "content": "### argmax\n\n`argmax(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturns the indices of the maximum values along an axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to find argmax. null finds argmax of flattened array.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "argmin",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "argmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>",
      "description": "Returns the indices of the minimum values along an axis.",
      "content": "### argmin\n\n`argmin(a: NDArray, axis: null | number, keepdims: boolean): Promise<number | NDArray>`\n\nReturns the indices of the minimum values along an axis.\n\n**Parameters:**\n- `a` (NDArray) — Input array\n- `axis` (null | number) — Axis along which to find argmin. null finds argmin of flattened array.\n- `keepdims` (boolean) — If true, reduced axes are left with size 1\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "argpartition",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "argpartition(a: NDArray, kth: number, axis: number): Promise<NDArray>",
      "description": "Returns the indices that would partition an array.",
      "content": "### argpartition\n\n`argpartition(a: NDArray, kth: number, axis: number): Promise<NDArray>`\n\nReturns the indices that would partition an array.\n\n**Parameters:**\n- `a` (NDArray) — Array to partition\n- `kth` (number) — Index to partition around\n- `axis` (number) — Axis along which to partition (default: -1)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "argsort",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "argsort(a: NDArray, axis: null | number, kind: SortKind): Promise<NDArray>",
      "description": "Returns the indices that would sort an array.",
      "content": "### argsort\n\n`argsort(a: NDArray, axis: null | number, kind: SortKind): Promise<NDArray>`\n\nReturns the indices that would sort an array.\n\n**Parameters:**\n- `a` (NDArray) — Array to sort\n- `axis` (null | number) — Axis along which to sort. null flattens the array.\n              Default is -1 (last axis).\n- `kind` (SortKind) — Sorting algorithm\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "countNonzero",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "countNonzero(arr: NDArray): Promise<number>",
      "description": "Count the number of nonzero elements in an array.",
      "content": "### countNonzero\n\n`countNonzero(arr: NDArray): Promise<number>`\n\nCount the number of nonzero elements in an array.\n\n**Parameters:**\n- `arr` (NDArray) — Input array\n\n**Returns:** `Promise<number>`\n"
    },
    {
      "name": "partition",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "partition(a: NDArray, kth: number, axis: number): Promise<NDArray>",
      "description": "Return a partitioned copy of an array.  Creates a copy of the array with its elements rearranged so that elements smaller than the kth element are moved before it and elements greater are moved after it.",
      "content": "### partition\n\n`partition(a: NDArray, kth: number, axis: number): Promise<NDArray>`\n\nReturn a partitioned copy of an array.  Creates a copy of the array with its elements rearranged so that elements smaller than the kth element are moved before it and elements greater are moved after it.\n\n**Parameters:**\n- `a` (NDArray) — Array to partition\n- `kth` (number) — Index to partition around\n- `axis` (number) — Axis along which to partition (default: -1)\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "searchsorted",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "searchsorted(a: NDArray, v: number | NDArray | number[], side: \"left\" | \"right\"): Promise<number | NDArray>",
      "description": "Find indices where elements should be inserted to maintain order.",
      "content": "### searchsorted\n\n`searchsorted(a: NDArray, v: number | NDArray | number[], side: \"left\" | \"right\"): Promise<number | NDArray>`\n\nFind indices where elements should be inserted to maintain order.\n\n**Parameters:**\n- `a` (NDArray) — Sorted 1D input array\n- `v` (number | NDArray | number[]) — Values to insert\n- `side` (\"left\" | \"right\") — 'left' or 'right' side to insert\n\n**Returns:** `Promise<number | NDArray>`\n"
    },
    {
      "name": "sort",
      "module": null,
      "category": "Sorting & Searching",
      "signature": "sort(a: NDArray, axis: null | number, kind: SortKind): Promise<NDArray>",
      "description": "Return a sorted copy of an array.",
      "content": "### sort\n\n`sort(a: NDArray, axis: null | number, kind: SortKind): Promise<NDArray>`\n\nReturn a sorted copy of an array.\n\n**Parameters:**\n- `a` (NDArray) — Array to sort\n- `axis` (null | number) — Axis along which to sort. null flattens the array.\n              Default is -1 (last axis).\n- `kind` (SortKind) — Sorting algorithm: 'quicksort', 'mergesort', 'heapsort', or 'stable'\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "in1d",
      "module": null,
      "category": "Set Operations",
      "signature": "in1d(ar1: NDArray, ar2: NDArray, options: IsinOptions): Promise<NDArray>",
      "description": "Test whether each element of ar1 is also present in ar2 (flat version).",
      "content": "### in1d\n\n`in1d(ar1: NDArray, ar2: NDArray, options: IsinOptions): Promise<NDArray>`\n\nTest whether each element of ar1 is also present in ar2 (flat version).\n\n**Parameters:**\n- `ar1` (NDArray) — Input array (will be flattened)\n- `ar2` (NDArray) — Values to test against\n- `options` (IsinOptions) — Configuration options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "intersect1d",
      "module": null,
      "category": "Set Operations",
      "signature": "intersect1d(ar1: NDArray, ar2: NDArray, options: IntersectOptions): Promise<NDArray | object>",
      "description": "Find the intersection of two arrays.  Returns the sorted unique values that are in both input arrays.",
      "content": "### intersect1d\n\n`intersect1d(ar1: NDArray, ar2: NDArray, options: IntersectOptions): Promise<NDArray | object>`\n\nFind the intersection of two arrays.  Returns the sorted unique values that are in both input arrays.\n\n**Parameters:**\n- `ar1` (NDArray) — First input array\n- `ar2` (NDArray) — Second input array\n- `options` (IntersectOptions) — Configuration options\n\n**Returns:** `Promise<NDArray | object>`\n"
    },
    {
      "name": "isin",
      "module": null,
      "category": "Set Operations",
      "signature": "isin(ar1: NDArray, ar2: NDArray, options: IsinOptions): Promise<NDArray>",
      "description": "Test whether each element of ar1 is also present in ar2.  Returns a boolean array of the same shape as ar1.",
      "content": "### isin\n\n`isin(ar1: NDArray, ar2: NDArray, options: IsinOptions): Promise<NDArray>`\n\nTest whether each element of ar1 is also present in ar2.  Returns a boolean array of the same shape as ar1.\n\n**Parameters:**\n- `ar1` (NDArray) — Input array\n- `ar2` (NDArray) — Values to test against\n- `options` (IsinOptions) — Configuration options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "setdiff1d",
      "module": null,
      "category": "Set Operations",
      "signature": "setdiff1d(ar1: NDArray, ar2: NDArray, options: SetDiffOptions): Promise<NDArray>",
      "description": "Find the set difference of two arrays.  Returns the sorted unique values in ar1 that are not in ar2.",
      "content": "### setdiff1d\n\n`setdiff1d(ar1: NDArray, ar2: NDArray, options: SetDiffOptions): Promise<NDArray>`\n\nFind the set difference of two arrays.  Returns the sorted unique values in ar1 that are not in ar2.\n\n**Parameters:**\n- `ar1` (NDArray) — First input array\n- `ar2` (NDArray) — Second input array\n- `options` (SetDiffOptions) — Configuration options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "setxor1d",
      "module": null,
      "category": "Set Operations",
      "signature": "setxor1d(ar1: NDArray, ar2: NDArray, options: SetXorOptions): Promise<NDArray>",
      "description": "Find the set exclusive-or of two arrays.  Returns the sorted unique values in exactly one (not both) of the input arrays.",
      "content": "### setxor1d\n\n`setxor1d(ar1: NDArray, ar2: NDArray, options: SetXorOptions): Promise<NDArray>`\n\nFind the set exclusive-or of two arrays.  Returns the sorted unique values in exactly one (not both) of the input arrays.\n\n**Parameters:**\n- `ar1` (NDArray) — First input array\n- `ar2` (NDArray) — Second input array\n- `options` (SetXorOptions) — Configuration options\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "union1d",
      "module": null,
      "category": "Set Operations",
      "signature": "union1d(ar1: NDArray, ar2: NDArray): Promise<NDArray>",
      "description": "Find the union of two arrays.  Returns the sorted unique values that are in either of the input arrays.",
      "content": "### union1d\n\n`union1d(ar1: NDArray, ar2: NDArray): Promise<NDArray>`\n\nFind the union of two arrays.  Returns the sorted unique values that are in either of the input arrays.\n\n**Parameters:**\n- `ar1` (NDArray) — First input array\n- `ar2` (NDArray) — Second input array\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "bitwise_and",
      "module": null,
      "category": "Bitwise",
      "signature": "bitwise_and(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the bit-wise AND of two arrays element-wise.",
      "content": "### bitwise_and\n\n`bitwise_and(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the bit-wise AND of two arrays element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "bitwise_count",
      "module": null,
      "category": "Bitwise",
      "signature": "bitwise_count(x: NDArray): NDArray",
      "description": "Computes the number of 1-bits in the absolute value of x. Also known as popcount or population count. Input array must be integers.",
      "content": "### bitwise_count\n\n`bitwise_count(x: NDArray): NDArray`\n\nComputes the number of 1-bits in the absolute value of x. Also known as popcount or population count. Input array must be integers.\n\n**Parameters:**\n- `x` (NDArray) — Input array of integers\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "bitwise_not",
      "module": null,
      "category": "Bitwise",
      "signature": "bitwise_not(x: NDArray): NDArray",
      "description": "Alias for invert.",
      "content": "### bitwise_not\n\n`bitwise_not(x: NDArray): NDArray`\n\nAlias for invert.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "bitwise_or",
      "module": null,
      "category": "Bitwise",
      "signature": "bitwise_or(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the bit-wise OR of two arrays element-wise.",
      "content": "### bitwise_or\n\n`bitwise_or(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the bit-wise OR of two arrays element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "bitwise_xor",
      "module": null,
      "category": "Bitwise",
      "signature": "bitwise_xor(x1: NDArray, x2: NDArray): NDArray",
      "description": "Compute the bit-wise XOR of two arrays element-wise.",
      "content": "### bitwise_xor\n\n`bitwise_xor(x1: NDArray, x2: NDArray): NDArray`\n\nCompute the bit-wise XOR of two arrays element-wise.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "invert",
      "module": null,
      "category": "Bitwise",
      "signature": "invert(x: NDArray): NDArray",
      "description": "Compute bit-wise inversion, element-wise.",
      "content": "### invert\n\n`invert(x: NDArray): NDArray`\n\nCompute bit-wise inversion, element-wise.\n\n**Parameters:**\n- `x` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "left_shift",
      "module": null,
      "category": "Bitwise",
      "signature": "left_shift(x1: NDArray, x2: NDArray): NDArray",
      "description": "Shift the bits of an integer to the left.",
      "content": "### left_shift\n\n`left_shift(x1: NDArray, x2: NDArray): NDArray`\n\nShift the bits of an integer to the left.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "right_shift",
      "module": null,
      "category": "Bitwise",
      "signature": "right_shift(x1: NDArray, x2: NDArray): NDArray",
      "description": "Shift the bits of an integer to the right.",
      "content": "### right_shift\n\n`right_shift(x1: NDArray, x2: NDArray): NDArray`\n\nShift the bits of an integer to the right.\n\n**Parameters:**\n- `x1` (NDArray)\n- `x2` (NDArray)\n\n**Returns:** `NDArray`\n"
    },
    {
      "name": "array2string",
      "module": null,
      "category": "I/O",
      "signature": "array2string(arr: NDArray, options: PrintOptions): string",
      "description": "Return a string representation of an array.",
      "content": "### array2string\n\n`array2string(arr: NDArray, options: PrintOptions): string`\n\nReturn a string representation of an array.\n\n**Parameters:**\n- `arr` (NDArray) — Array to convert\n- `options` (PrintOptions) — Override print options\n\n**Returns:** `string`\n"
    },
    {
      "name": "arrayRepr",
      "module": null,
      "category": "I/O",
      "signature": "arrayRepr(arr: NDArray, options: PrintOptions): string",
      "description": "Return the string representation of an array (with dtype info).",
      "content": "### arrayRepr\n\n`arrayRepr(arr: NDArray, options: PrintOptions): string`\n\nReturn the string representation of an array (with dtype info).\n\n**Parameters:**\n- `arr` (NDArray) — Array to represent\n- `options` (PrintOptions) — Override print options\n\n**Returns:** `string`\n"
    },
    {
      "name": "arrayStr",
      "module": null,
      "category": "I/O",
      "signature": "arrayStr(arr: NDArray, options: PrintOptions): string",
      "description": "Return a string representation of an array (no dtype).",
      "content": "### arrayStr\n\n`arrayStr(arr: NDArray, options: PrintOptions): string`\n\nReturn a string representation of an array (no dtype).\n\n**Parameters:**\n- `arr` (NDArray) — Array to represent\n- `options` (PrintOptions) — Override print options\n\n**Returns:** `string`\n"
    },
    {
      "name": "baseRepr",
      "module": null,
      "category": "I/O",
      "signature": "baseRepr(num: number, base: number, padding: number): string",
      "description": "Return a string representation of a number in the given base.",
      "content": "### baseRepr\n\n`baseRepr(num: number, base: number, padding: number): string`\n\nReturn a string representation of a number in the given base.\n\n**Parameters:**\n- `num` (number) — Integer to convert\n- `base` (number) — Number base (2-36)\n- `padding` (number) — Minimum number of digits\n\n**Returns:** `string`\n"
    },
    {
      "name": "baseReprArray",
      "module": null,
      "category": "I/O",
      "signature": "baseReprArray(arr: number[], base: number, padding: number): string[]",
      "description": "Convert an array of numbers to base-N representations.",
      "content": "### baseReprArray\n\n`baseReprArray(arr: number[], base: number, padding: number): string[]`\n\nConvert an array of numbers to base-N representations.\n\n**Parameters:**\n- `arr` (number[]) — Array of integers\n- `base` (number) — Number base (2-36)\n- `padding` (number) — Minimum digits per number\n\n**Returns:** `string[]`\n"
    },
    {
      "name": "binaryRepr",
      "module": null,
      "category": "I/O",
      "signature": "binaryRepr(num: number, width?: number): string",
      "description": "Return the binary representation of a number as a string.  For negative numbers, uses two's complement representation if width is provided, otherwise returns the binary representation with a minus sign.",
      "content": "### binaryRepr\n\n`binaryRepr(num: number, width?: number): string`\n\nReturn the binary representation of a number as a string.  For negative numbers, uses two's complement representation if width is provided, otherwise returns the binary representation with a minus sign.\n\n**Parameters:**\n- `num` (number) — Integer to convert\n- `width` (number) (optional) — Fixed width for two's complement representation\n\n**Returns:** `string`\n"
    },
    {
      "name": "binaryReprArray",
      "module": null,
      "category": "I/O",
      "signature": "binaryReprArray(arr: number[], width?: number): string[]",
      "description": "Convert an array of numbers to binary representations.",
      "content": "### binaryReprArray\n\n`binaryReprArray(arr: number[], width?: number): string[]`\n\nConvert an array of numbers to binary representations.\n\n**Parameters:**\n- `arr` (number[]) — Array of integers\n- `width` (number) (optional) — Fixed width for all representations\n\n**Returns:** `string[]`\n"
    },
    {
      "name": "formatFloatPositional",
      "module": null,
      "category": "I/O",
      "signature": "formatFloatPositional(value: number, precision: number, _unique: boolean, fractional: boolean, trim: \"k\" | \".\" | \"0\" | \"-\", sign: boolean, padLeft: number, padRight: number): string",
      "description": "Format a float in positional notation.",
      "content": "### formatFloatPositional\n\n`formatFloatPositional(value: number, precision: number, _unique: boolean, fractional: boolean, trim: \"k\" | \".\" | \"0\" | \"-\", sign: boolean, padLeft: number, padRight: number): string`\n\nFormat a float in positional notation.\n\n**Parameters:**\n- `value` (number)\n- `precision` (number)\n- `_unique` (boolean)\n- `fractional` (boolean)\n- `trim` (\"k\" | \".\" | \"0\" | \"-\")\n- `sign` (boolean)\n- `padLeft` (number)\n- `padRight` (number)\n\n**Returns:** `string`\n"
    },
    {
      "name": "formatFloatScientific",
      "module": null,
      "category": "I/O",
      "signature": "formatFloatScientific(value: number, precision: number, _unique: boolean, trim: \"k\" | \".\" | \"0\" | \"-\", sign: boolean, padLeft: number, expDigits: number): string",
      "description": "Format a float in scientific notation.",
      "content": "### formatFloatScientific\n\n`formatFloatScientific(value: number, precision: number, _unique: boolean, trim: \"k\" | \".\" | \"0\" | \"-\", sign: boolean, padLeft: number, expDigits: number): string`\n\nFormat a float in scientific notation.\n\n**Parameters:**\n- `value` (number)\n- `precision` (number)\n- `_unique` (boolean)\n- `trim` (\"k\" | \".\" | \"0\" | \"-\")\n- `sign` (boolean)\n- `padLeft` (number)\n- `expDigits` (number)\n\n**Returns:** `string`\n"
    },
    {
      "name": "formatValue",
      "module": null,
      "category": "I/O",
      "signature": "formatValue(value: number, fmt: string): string",
      "description": "Format a number according to printf-style format string.",
      "content": "### formatValue\n\n`formatValue(value: number, fmt: string): string`\n\nFormat a number according to printf-style format string.\n\n**Parameters:**\n- `value` (number)\n- `fmt` (string)\n\n**Returns:** `string`\n"
    },
    {
      "name": "fromBaseRepr",
      "module": null,
      "category": "I/O",
      "signature": "fromBaseRepr(str: string, base: number): number",
      "description": "Convert a base-N string to a number.",
      "content": "### fromBaseRepr\n\n`fromBaseRepr(str: string, base: number): number`\n\nConvert a base-N string to a number.\n\n**Parameters:**\n- `str` (string) — String representation\n- `base` (number) — Number base (2-36)\n\n**Returns:** `number`\n"
    },
    {
      "name": "fromBinaryRepr",
      "module": null,
      "category": "I/O",
      "signature": "fromBinaryRepr(binary: string, twosComplement: boolean, width?: number): number",
      "description": "Convert a binary string to a number.",
      "content": "### fromBinaryRepr\n\n`fromBinaryRepr(binary: string, twosComplement: boolean, width?: number): number`\n\nConvert a binary string to a number.\n\n**Parameters:**\n- `binary` (string) — Binary string (optionally with '0b' prefix)\n- `twosComplement` (boolean)\n- `width` (number) (optional)\n\n**Returns:** `number`\n"
    },
    {
      "name": "getPrintoptions",
      "module": null,
      "category": "I/O",
      "signature": "getPrintoptions(): Required<PrintOptions>",
      "description": "Get current print options.",
      "content": "### getPrintoptions\n\n`getPrintoptions(): Required<PrintOptions>`\n\nGet current print options.\n\n**Returns:** `Required<PrintOptions>`\n"
    },
    {
      "name": "hexRepr",
      "module": null,
      "category": "I/O",
      "signature": "hexRepr(num: number, width: number): string",
      "description": "Return the hexadecimal representation of a number.",
      "content": "### hexRepr\n\n`hexRepr(num: number, width: number): string`\n\nReturn the hexadecimal representation of a number.\n\n**Parameters:**\n- `num` (number) — Integer to convert\n- `width` (number) — Minimum number of hex digits\n\n**Returns:** `string`\n"
    },
    {
      "name": "octalRepr",
      "module": null,
      "category": "I/O",
      "signature": "octalRepr(num: number, width: number): string",
      "description": "Return the octal representation of a number.",
      "content": "### octalRepr\n\n`octalRepr(num: number, width: number): string`\n\nReturn the octal representation of a number.\n\n**Parameters:**\n- `num` (number) — Integer to convert\n- `width` (number) — Minimum number of octal digits\n\n**Returns:** `string`\n"
    },
    {
      "name": "openMemmap",
      "module": null,
      "category": "I/O",
      "signature": "openMemmap(file: string | ArrayBuffer, options: MemmapOptions): Promise<Memmap>",
      "description": "Open a memory-mapped file.  Convenience function wrapping Memmap.open().",
      "content": "### openMemmap\n\n`openMemmap(file: string | ArrayBuffer, options: MemmapOptions): Promise<Memmap>`\n\nOpen a memory-mapped file.  Convenience function wrapping Memmap.open().\n\n**Parameters:**\n- `file` (string | ArrayBuffer) — File path or ArrayBuffer\n- `options` (MemmapOptions) — Memmap options\n\n**Returns:** `Promise<Memmap>`\n"
    },
    {
      "name": "resetPrintoptions",
      "module": null,
      "category": "I/O",
      "signature": "resetPrintoptions(): void",
      "description": "Reset print options to defaults.",
      "content": "### resetPrintoptions\n\n`resetPrintoptions(): void`\n\nReset print options to defaults.\n\n**Returns:** `void`\n"
    },
    {
      "name": "save",
      "module": null,
      "category": "I/O",
      "signature": "save(file: null | string | FileSystemFileHandle, arr: NDArray, _options: SaveOptions): Promise<void | ArrayBuffer>",
      "description": "Save an array to a binary file in NPY format.",
      "content": "### save\n\n`save(file: null | string | FileSystemFileHandle, arr: NDArray, _options: SaveOptions): Promise<void | ArrayBuffer>`\n\nSave an array to a binary file in NPY format.\n\n**Parameters:**\n- `file` (null | string | FileSystemFileHandle) — File path (Node.js), FileSystemFileHandle (browser), or null to return ArrayBuffer\n- `arr` (NDArray) — Array to save\n- `_options` (SaveOptions)\n\n**Returns:** `Promise<void | ArrayBuffer>`\n"
    },
    {
      "name": "savetxt",
      "module": null,
      "category": "I/O",
      "signature": "savetxt(file: string | FileSystemFileHandle, arr: NDArray, options: SavetxtOptions): Promise<void>",
      "description": "Save an array to a text file.",
      "content": "### savetxt\n\n`savetxt(file: string | FileSystemFileHandle, arr: NDArray, options: SavetxtOptions): Promise<void>`\n\nSave an array to a text file.\n\n**Parameters:**\n- `file` (string | FileSystemFileHandle) — Output file (path or FileSystemFileHandle)\n- `arr` (NDArray) — 1D or 2D array to save\n- `options` (SavetxtOptions) — Formatting options\n\n**Returns:** `Promise<void>`\n"
    },
    {
      "name": "setPrintoptions",
      "module": null,
      "category": "I/O",
      "signature": "setPrintoptions(options: PrintOptions): void",
      "description": "Set printing options globally.",
      "content": "### setPrintoptions\n\n`setPrintoptions(options: PrintOptions): void`\n\nSet printing options globally.\n\n**Parameters:**\n- `options` (PrintOptions) — New print options (partial, merged with current)\n\n**Returns:** `void`\n"
    },
    {
      "name": "withPrintoptions",
      "module": null,
      "category": "I/O",
      "signature": "withPrintoptions(options: PrintOptions, fn: object): T",
      "description": "Execute a function with temporary print options.",
      "content": "### withPrintoptions\n\n`withPrintoptions(options: PrintOptions, fn: object): T`\n\nExecute a function with temporary print options.\n\n**Parameters:**\n- `options` (PrintOptions) — Temporary print options\n- `fn` (object) — Function to execute\n\n**Returns:** `T`\n"
    },
    {
      "name": "bartlett",
      "module": null,
      "category": "Window Functions",
      "signature": "bartlett(M: number): Promise<NDArray>",
      "description": "Return the Bartlett window.  The Bartlett window is very similar to a triangular window, except that the end points are at zero. Also known as the triangular or Fejér window.  Formula:   w(n) = 1 + n/(M-1) for n <= 0   w(n) = 1 - n/(M-1) for n > 0",
      "content": "### bartlett\n\n`bartlett(M: number): Promise<NDArray>`\n\nReturn the Bartlett window.  The Bartlett window is very similar to a triangular window, except that the end points are at zero. Also known as the triangular or Fejér window.  Formula:   w(n) = 1 + n/(M-1) for n <= 0   w(n) = 1 - n/(M-1) for n > 0\n\n**Parameters:**\n- `M` (number) — Number of points in the output window. If zero or less,\n           an empty array is returned.\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "blackman",
      "module": null,
      "category": "Window Functions",
      "signature": "blackman(M: number): Promise<NDArray>",
      "description": "Return the Blackman window.  The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible.  Formula: w(n) = 0.42 + 0.5*cos(π*n/(M-1)) + 0.08*cos(2π*n/(M-1))",
      "content": "### blackman\n\n`blackman(M: number): Promise<NDArray>`\n\nReturn the Blackman window.  The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible.  Formula: w(n) = 0.42 + 0.5*cos(π*n/(M-1)) + 0.08*cos(2π*n/(M-1))\n\n**Parameters:**\n- `M` (number) — Number of points in the output window. If zero or less,\n           an empty array is returned.\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "hamming",
      "module": null,
      "category": "Window Functions",
      "signature": "hamming(M: number): Promise<NDArray>",
      "description": "Return the Hamming window.  The Hamming window is a taper formed by using a weighted cosine, similar to Hanning but with raised endpoints to reduce the first side lobe.  Formula: w(n) = 0.54 + 0.46*cos(π*n/(M-1))",
      "content": "### hamming\n\n`hamming(M: number): Promise<NDArray>`\n\nReturn the Hamming window.  The Hamming window is a taper formed by using a weighted cosine, similar to Hanning but with raised endpoints to reduce the first side lobe.  Formula: w(n) = 0.54 + 0.46*cos(π*n/(M-1))\n\n**Parameters:**\n- `M` (number) — Number of points in the output window. If zero or less,\n           an empty array is returned.\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "hanning",
      "module": null,
      "category": "Window Functions",
      "signature": "hanning(M: number): Promise<NDArray>",
      "description": "Return the Hanning window (also known as Hann window).  The Hanning window is a taper formed by using a weighted cosine. Named for Julius von Hann.  Formula: w(n) = 0.5 + 0.5*cos(π*n/(M-1))",
      "content": "### hanning\n\n`hanning(M: number): Promise<NDArray>`\n\nReturn the Hanning window (also known as Hann window).  The Hanning window is a taper formed by using a weighted cosine. Named for Julius von Hann.  Formula: w(n) = 0.5 + 0.5*cos(π*n/(M-1))\n\n**Parameters:**\n- `M` (number) — Number of points in the output window. If zero or less,\n           an empty array is returned.\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "kaiser",
      "module": null,
      "category": "Window Functions",
      "signature": "kaiser(M: number, beta: number): Promise<NDArray>",
      "description": "Return the Kaiser window.  The Kaiser window is a taper formed by using a Bessel function. It provides a good approximation to the Digital Prolate Spheroidal Sequence (DPSS/Slepian window).  Formula: w(n) = I₀(β * sqrt(1 - (2n/(M-1))²)) / I₀(β)  The beta parameter controls the window shape: - β = 0: Rectangular window - β ≈ 5: Similar to Hamming - β ≈ 6: Similar to Hanning - β ≈ 8.6: Similar to Blackman - β = 14: Good starting point for most applications",
      "content": "### kaiser\n\n`kaiser(M: number, beta: number): Promise<NDArray>`\n\nReturn the Kaiser window.  The Kaiser window is a taper formed by using a Bessel function. It provides a good approximation to the Digital Prolate Spheroidal Sequence (DPSS/Slepian window).  Formula: w(n) = I₀(β * sqrt(1 - (2n/(M-1))²)) / I₀(β)  The beta parameter controls the window shape: - β = 0: Rectangular window - β ≈ 5: Similar to Hamming - β ≈ 6: Similar to Hanning - β ≈ 8.6: Similar to Blackman - β = 14: Good starting point for most applications\n\n**Parameters:**\n- `M` (number) — Number of points in the output window. If zero or less,\n           an empty array is returned.\n- `beta` (number) — Shape parameter for the window. Larger values produce\n              narrower main lobe with lower side lobes.\n\n**Returns:** `Promise<NDArray>`\n"
    },
    {
      "name": "CastingKind",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "CastingKind",
      "description": "Casting safety levels",
      "content": "### CastingKind\n\n`CastingKind`\n\nCasting safety levels\n"
    },
    {
      "name": "DType",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "DType",
      "description": "Data type enum - matches the C DType enum in dtype.h",
      "content": "### DType\n\n`DType`\n\nData type enum - matches the C DType enum in dtype.h\n"
    },
    {
      "name": "Complex",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface Complex",
      "description": "Complex number representation",
      "content": "### Complex\n\n`interface Complex`\n\nComplex number representation\n"
    },
    {
      "name": "Ediff1dOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface Ediff1dOptions",
      "description": "",
      "content": "### Ediff1dOptions\n\n`interface Ediff1dOptions`\n"
    },
    {
      "name": "EigResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface EigResult",
      "description": "Result of eigenvalue decomposition.",
      "content": "### EigResult\n\n`interface EigResult`\n\nResult of eigenvalue decomposition.\n"
    },
    {
      "name": "FieldDescriptor",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface FieldDescriptor",
      "description": "Descriptor for a single field in a structured dtype.",
      "content": "### FieldDescriptor\n\n`interface FieldDescriptor`\n\nDescriptor for a single field in a structured dtype.\n"
    },
    {
      "name": "FrombufferOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface FrombufferOptions",
      "description": "Options for frombuffer()",
      "content": "### FrombufferOptions\n\n`interface FrombufferOptions`\n\nOptions for frombuffer()\n"
    },
    {
      "name": "FromfileOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface FromfileOptions",
      "description": "Options for fromfile()",
      "content": "### FromfileOptions\n\n`interface FromfileOptions`\n\nOptions for fromfile()\n"
    },
    {
      "name": "FromregexOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface FromregexOptions",
      "description": "Options for fromregex()",
      "content": "### FromregexOptions\n\n`interface FromregexOptions`\n\nOptions for fromregex()\n"
    },
    {
      "name": "GenfromtxtOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface GenfromtxtOptions",
      "description": "Options for genfromtxt()",
      "content": "### GenfromtxtOptions\n\n`interface GenfromtxtOptions`\n\nOptions for genfromtxt()\n"
    },
    {
      "name": "Histogram2DResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface Histogram2DResult",
      "description": "Result of 2D histogram computation.",
      "content": "### Histogram2DResult\n\n`interface Histogram2DResult`\n\nResult of 2D histogram computation.\n"
    },
    {
      "name": "HistogramDDResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface HistogramDDResult",
      "description": "Result of N-dimensional histogram computation.",
      "content": "### HistogramDDResult\n\n`interface HistogramDDResult`\n\nResult of N-dimensional histogram computation.\n"
    },
    {
      "name": "HistogramResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface HistogramResult",
      "description": "Result of histogram computation.",
      "content": "### HistogramResult\n\n`interface HistogramResult`\n\nResult of histogram computation.\n"
    },
    {
      "name": "IndexSpec",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface IndexSpec",
      "description": "Parsed index specification for a single index element. Used for communication with C layer.",
      "content": "### IndexSpec\n\n`interface IndexSpec`\n\nParsed index specification for a single index element. Used for communication with C layer.\n"
    },
    {
      "name": "IntersectOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface IntersectOptions",
      "description": "",
      "content": "### IntersectOptions\n\n`interface IntersectOptions`\n"
    },
    {
      "name": "IsinOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface IsinOptions",
      "description": "",
      "content": "### IsinOptions\n\n`interface IsinOptions`\n"
    },
    {
      "name": "LoadOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface LoadOptions",
      "description": "Options for load()",
      "content": "### LoadOptions\n\n`interface LoadOptions`\n\nOptions for load()\n"
    },
    {
      "name": "LoadtxtOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface LoadtxtOptions",
      "description": "Options for loadtxt()",
      "content": "### LoadtxtOptions\n\n`interface LoadtxtOptions`\n\nOptions for loadtxt()\n"
    },
    {
      "name": "LstsqResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface LstsqResult",
      "description": "Result of least squares solution.",
      "content": "### LstsqResult\n\n`interface LstsqResult`\n\nResult of least squares solution.\n"
    },
    {
      "name": "MemmapOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface MemmapOptions",
      "description": "Options for creating/opening a memmap.",
      "content": "### MemmapOptions\n\n`interface MemmapOptions`\n\nOptions for creating/opening a memmap.\n"
    },
    {
      "name": "NDArrayFlags",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface NDArrayFlags",
      "description": "Array flags interface",
      "content": "### NDArrayFlags\n\n`interface NDArrayFlags`\n\nArray flags interface\n"
    },
    {
      "name": "NDArrayOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface NDArrayOptions",
      "description": "Options for NDArray creation",
      "content": "### NDArrayOptions\n\n`interface NDArrayOptions`\n\nOptions for NDArray creation\n"
    },
    {
      "name": "PrintOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface PrintOptions",
      "description": "Print formatting options.",
      "content": "### PrintOptions\n\n`interface PrintOptions`\n\nPrint formatting options.\n"
    },
    {
      "name": "QRResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface QRResult",
      "description": "Result of QR decomposition.",
      "content": "### QRResult\n\n`interface QRResult`\n\nResult of QR decomposition.\n"
    },
    {
      "name": "RecArrayOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface RecArrayOptions",
      "description": "Options for creating record arrays.",
      "content": "### RecArrayOptions\n\n`interface RecArrayOptions`\n\nOptions for creating record arrays.\n"
    },
    {
      "name": "SaveOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SaveOptions",
      "description": "Options for save()",
      "content": "### SaveOptions\n\n`interface SaveOptions`\n\nOptions for save()\n"
    },
    {
      "name": "SavetxtOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SavetxtOptions",
      "description": "Options for savetxt()",
      "content": "### SavetxtOptions\n\n`interface SavetxtOptions`\n\nOptions for savetxt()\n"
    },
    {
      "name": "SetDiffOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SetDiffOptions",
      "description": "",
      "content": "### SetDiffOptions\n\n`interface SetDiffOptions`\n"
    },
    {
      "name": "SetXorOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SetXorOptions",
      "description": "",
      "content": "### SetXorOptions\n\n`interface SetXorOptions`\n"
    },
    {
      "name": "SliceInfo",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SliceInfo",
      "description": "Slice type for contiguous regions.",
      "content": "### SliceInfo\n\n`interface SliceInfo`\n\nSlice type for contiguous regions.\n"
    },
    {
      "name": "SlogdetResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SlogdetResult",
      "description": "Result of sign and log determinant.",
      "content": "### SlogdetResult\n\n`interface SlogdetResult`\n\nResult of sign and log determinant.\n"
    },
    {
      "name": "StructuredDType",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface StructuredDType",
      "description": "Structured data type with named fields. Represents the dtype of a record array.",
      "content": "### StructuredDType\n\n`interface StructuredDType`\n\nStructured data type with named fields. Represents the dtype of a record array.\n"
    },
    {
      "name": "SVDResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface SVDResult",
      "description": "Result of singular value decomposition.",
      "content": "### SVDResult\n\n`interface SVDResult`\n\nResult of singular value decomposition.\n"
    },
    {
      "name": "UfuncLike",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface UfuncLike",
      "description": "A ufunc-like callable created from a JavaScript function.",
      "content": "### UfuncLike\n\n`interface UfuncLike`\n\nA ufunc-like callable created from a JavaScript function.\n\n**Parameters:**\n- `args` (number | NDArray[]) (rest)\n\n**Returns:** `Promise<NDArray | NDArray[]>`\n"
    },
    {
      "name": "UniqueOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface UniqueOptions",
      "description": "",
      "content": "### UniqueOptions\n\n`interface UniqueOptions`\n"
    },
    {
      "name": "UniqueResult",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface UniqueResult",
      "description": "Result from unique() when returning additional arrays.",
      "content": "### UniqueResult\n\n`interface UniqueResult`\n\nResult from unique() when returning additional arrays.\n"
    },
    {
      "name": "VectorizeOptions",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface VectorizeOptions",
      "description": "Options for vectorize.",
      "content": "### VectorizeOptions\n\n`interface VectorizeOptions`\n\nOptions for vectorize.\n"
    },
    {
      "name": "WasmLoadConfig",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface WasmLoadConfig",
      "description": "Configuration options for WASM module loading",
      "content": "### WasmLoadConfig\n\n`interface WasmLoadConfig`\n\nConfiguration options for WASM module loading\n"
    },
    {
      "name": "WasmModule",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "interface WasmModule",
      "description": "WASM Module interface - defines the functions exported from the C code",
      "content": "### WasmModule\n\n`interface WasmModule`\n\nWASM Module interface - defines the functions exported from the C code\n"
    },
    {
      "name": "BinMethod",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "BinMethod",
      "description": "Supported bin estimation methods.",
      "content": "### BinMethod\n\n`BinMethod`\n\nSupported bin estimation methods.\n"
    },
    {
      "name": "ClipMode",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "ClipMode",
      "description": "Clip mode type",
      "content": "### ClipMode\n\n`ClipMode`\n\nClip mode type\n"
    },
    {
      "name": "Ellipsis",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "Ellipsis",
      "description": "",
      "content": "### Ellipsis\n\n`Ellipsis`\n"
    },
    {
      "name": "FFTNorm",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "FFTNorm",
      "description": "FFT normalization modes. - \"backward\": No scaling on forward, 1/n on inverse (default) - \"ortho\": 1/sqrt(n) on both forward and inverse - \"forward\": 1/n on forward, no scaling on inverse",
      "content": "### FFTNorm\n\n`FFTNorm`\n\nFFT normalization modes. - \"backward\": No scaling on forward, 1/n on inverse (default) - \"ortho\": 1/sqrt(n) on both forward and inverse - \"forward\": 1/n on forward, no scaling on inverse\n"
    },
    {
      "name": "IndexElement",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "IndexElement",
      "description": "Type for valid index elements in a slice operation.",
      "content": "### IndexElement\n\n`IndexElement`\n\nType for valid index elements in a slice operation.\n"
    },
    {
      "name": "IsinKind",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "IsinKind",
      "description": "",
      "content": "### IsinKind\n\n`IsinKind`\n"
    },
    {
      "name": "MaskedConstant",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "MaskedConstant",
      "description": "Type for the masked constant.",
      "content": "### MaskedConstant\n\n`MaskedConstant`\n\nType for the masked constant.\n"
    },
    {
      "name": "MaskType",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "MaskType",
      "description": "Type for mask: either a boolean NDArray or nomask sentinel.",
      "content": "### MaskType\n\n`MaskType`\n\nType for mask: either a boolean NDArray or nomask sentinel.\n"
    },
    {
      "name": "MemmapMode",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "MemmapMode",
      "description": "Memory mapping modes.",
      "content": "### MemmapMode\n\n`MemmapMode`\n\nMemory mapping modes.\n"
    },
    {
      "name": "Newaxis",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "Newaxis",
      "description": "",
      "content": "### Newaxis\n\n`Newaxis`\n"
    },
    {
      "name": "SizeType",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "SizeType",
      "description": "Size specification for random output arrays.",
      "content": "### SizeType\n\n`SizeType`\n\nSize specification for random output arrays.\n"
    },
    {
      "name": "SortKind",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "SortKind",
      "description": "",
      "content": "### SortKind\n\n`SortKind`\n"
    },
    {
      "name": "TypedArrayType",
      "module": null,
      "category": "Types & Interfaces",
      "signature": "TypedArrayType",
      "description": "Supported TypedArray types for array creation",
      "content": "### TypedArrayType\n\n`TypedArrayType`\n\nSupported TypedArray types for array creation\n"
    },
    {
      "name": "e",
      "module": null,
      "category": "Constants",
      "signature": "e",
      "description": "Euler's number, the base of natural logarithms.  `e = 2.718281828459045`",
      "content": "### e\n\n`e`\n\nEuler's number, the base of natural logarithms.  `e = 2.718281828459045`\n"
    },
    {
      "name": "ellipsis",
      "module": null,
      "category": "Constants",
      "signature": "ellipsis",
      "description": "Sentinel for ellipsis (...) in indexing. Expands to fill remaining dimensions with full slices.",
      "content": "### ellipsis\n\n`ellipsis`\n\nSentinel for ellipsis (...) in indexing. Expands to fill remaining dimensions with full slices.\n"
    },
    {
      "name": "euler_gamma",
      "module": null,
      "category": "Constants",
      "signature": "euler_gamma",
      "description": "Euler-Mascheroni constant (γ).  `γ = lim(n→∞) [1 + 1/2 + 1/3 + ... + 1/n - ln(n)]` `γ ≈ 0.5772156649015329`",
      "content": "### euler_gamma\n\n`euler_gamma`\n\nEuler-Mascheroni constant (γ).  `γ = lim(n→∞) [1 + 1/2 + 1/3 + ... + 1/n - ln(n)]` `γ ≈ 0.5772156649015329`\n"
    },
    {
      "name": "inf",
      "module": null,
      "category": "Constants",
      "signature": "inf",
      "description": "IEEE 754 positive infinity.",
      "content": "### inf\n\n`inf`\n\nIEEE 754 positive infinity.\n"
    },
    {
      "name": "nan",
      "module": null,
      "category": "Constants",
      "signature": "nan",
      "description": "IEEE 754 quiet Not-a-Number.  NaN is used to represent undefined or unrepresentable results in floating-point calculations (e.g., 0/0, sqrt(-1)).  Note: NaN is not equal to anything, including itself. Use `isnan()` to check for NaN values.",
      "content": "### nan\n\n`nan`\n\nIEEE 754 quiet Not-a-Number.  NaN is used to represent undefined or unrepresentable results in floating-point calculations (e.g., 0/0, sqrt(-1)).  Note: NaN is not equal to anything, including itself. Use `isnan()` to check for NaN values.\n"
    },
    {
      "name": "NAN",
      "module": null,
      "category": "Constants",
      "signature": "NAN",
      "description": "IEEE 754 quiet Not-a-Number (alias).",
      "content": "### NAN\n\n`NAN`\n\nIEEE 754 quiet Not-a-Number (alias).\n"
    },
    {
      "name": "newaxis",
      "module": null,
      "category": "Constants",
      "signature": "newaxis",
      "description": "Sentinel for newaxis in indexing. Inserts a new dimension of size 1.",
      "content": "### newaxis\n\n`newaxis`\n\nSentinel for newaxis in indexing. Inserts a new dimension of size 1.\n"
    },
    {
      "name": "NINF",
      "module": null,
      "category": "Constants",
      "signature": "NINF",
      "description": "IEEE 754 negative infinity.",
      "content": "### NINF\n\n`NINF`\n\nIEEE 754 negative infinity.\n"
    },
    {
      "name": "NZERO",
      "module": null,
      "category": "Constants",
      "signature": "NZERO",
      "description": "IEEE 754 negative zero.",
      "content": "### NZERO\n\n`NZERO`\n\nIEEE 754 negative zero.\n"
    },
    {
      "name": "pi",
      "module": null,
      "category": "Constants",
      "signature": "pi",
      "description": "Pi, the ratio of a circle's circumference to its diameter.  `π = 3.141592653589793`",
      "content": "### pi\n\n`pi`\n\nPi, the ratio of a circle's circumference to its diameter.  `π = 3.141592653589793`\n"
    },
    {
      "name": "PINF",
      "module": null,
      "category": "Constants",
      "signature": "PINF",
      "description": "IEEE 754 positive infinity (alias).",
      "content": "### PINF\n\n`PINF`\n\nIEEE 754 positive infinity (alias).\n"
    },
    {
      "name": "PZERO",
      "module": null,
      "category": "Constants",
      "signature": "PZERO",
      "description": "IEEE 754 positive zero.  JavaScript/IEEE 754 distinguishes between +0 and -0. They compare equal, but have different behavior in edge cases.",
      "content": "### PZERO\n\n`PZERO`\n\nIEEE 754 positive zero.  JavaScript/IEEE 754 distinguishes between +0 and -0. They compare equal, but have different behavior in edge cases.\n"
    }
  ]
}