/**
 * NumPy Comparison Tests
 *
 * Load test vectors generated by NumPy and verify that NumJS
 * produces matching results.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { NDArray, DType, loadWasmModule } from 'numwasm';
import { readFileSync } from 'fs';
import { join } from 'path';

// Type definitions for test vectors
interface TestCase {
  name: string;
  description: string;
  data: number[];
  shape: number[];
  dtype: string;
  expected_sum: number;
}

interface TestVectors {
  generated_by: string;
  numpy_version: string;
  test_count: number;
  test_cases: TestCase[];
}

// Map string dtype to DType enum
const DTYPE_MAP: Record<string, DType> = {
  float64: DType.Float64,
  float32: DType.Float32,
  int32: DType.Int32,
  int64: DType.Int64,
};

describe('NumPy Comparison Tests', () => {
  let testVectors: TestVectors;

  beforeAll(async () => {
    // Load WASM module
    await loadWasmModule();

    // Load test vectors
    const fixturesPath = join(__dirname, '../fixtures/test_vectors.json');
    try {
      const content = readFileSync(fixturesPath, 'utf-8');
      testVectors = JSON.parse(content) as TestVectors;
      console.log(
        `Loaded ${testVectors.test_count} test cases from NumPy ${testVectors.numpy_version}`
      );
    } catch (error) {
      throw new Error(
        `Failed to load test vectors. Run 'npm run generate-fixtures' first. Error: ${error}`
      );
    }
  });

  describe('sum() matches NumPy', () => {
    // We'll dynamically generate tests after loading fixtures
    it('should have loaded test vectors', () => {
      expect(testVectors).toBeDefined();
      expect(testVectors.test_cases.length).toBeGreaterThan(0);
    });
  });

  describe('individual test cases', () => {
    // These tests run after the fixtures are loaded in beforeAll
    // We use a generator pattern to create tests dynamically

    it('small_array_sum', async () => {
      const tc = findTestCase('small_array_sum');
      await runComparisonTest(tc);
    });

    it('medium_array_sum', async () => {
      const tc = findTestCase('medium_array_sum');
      await runComparisonTest(tc);
    });

    it('large_random_array_sum', async () => {
      const tc = findTestCase('large_random_array_sum');
      await runComparisonTest(tc);
    });

    it('precision_test', async () => {
      const tc = findTestCase('precision_test');
      await runComparisonTest(tc);
    });

    it('negative_values', async () => {
      const tc = findTestCase('negative_values');
      await runComparisonTest(tc);
    });

    it('2d_array_sum', async () => {
      const tc = findTestCase('2d_array_sum');
      await runComparisonTest(tc);
    });

    it('float32_array_sum', async () => {
      const tc = findTestCase('float32_array_sum');
      await runComparisonTest(tc);
    });

    it('int32_array_sum', async () => {
      const tc = findTestCase('int32_array_sum');
      await runComparisonTest(tc);
    });

    it('single_element', async () => {
      const tc = findTestCase('single_element');
      await runComparisonTest(tc);
    });

    it('all_zeros', async () => {
      const tc = findTestCase('all_zeros');
      await runComparisonTest(tc);
    });

    it('boundary_3_elements', async () => {
      const tc = findTestCase('boundary_3_elements');
      await runComparisonTest(tc);
    });

    it('boundary_8_elements', async () => {
      const tc = findTestCase('boundary_8_elements');
      await runComparisonTest(tc);
    });

    it('boundary_128_elements', async () => {
      const tc = findTestCase('boundary_128_elements');
      await runComparisonTest(tc);
    });

    it('boundary_129_elements', async () => {
      const tc = findTestCase('boundary_129_elements');
      await runComparisonTest(tc);
    });

    it('boundary_256_elements', async () => {
      const tc = findTestCase('boundary_256_elements');
      await runComparisonTest(tc);
    });
  });

  // Helper function to find a test case by name
  function findTestCase(name: string): TestCase {
    const tc = testVectors.test_cases.find((t) => t.name === name);
    if (!tc) {
      throw new Error(`Test case '${name}' not found in fixtures`);
    }
    return tc;
  }

  // Helper function to run a comparison test
  async function runComparisonTest(testCase: TestCase): Promise<void> {
    const dtype = DTYPE_MAP[testCase.dtype] ?? DType.Float64;

    // For multi-dimensional arrays, we pass flattened data
    // The shape is for reference, but sum() operates on all elements
    const arr = await NDArray.fromArray(testCase.data, [testCase.data.length], {
      dtype,
    });

    try {
      const result = arr.sum();
      const expected = testCase.expected_sum;

      // Determine appropriate tolerance based on dtype and array size
      if (dtype === DType.Float32) {
        // Float32 has less precision
        const tolerance = Math.abs(expected) * 1e-5 + 1e-5;
        expect(Math.abs(result - expected)).toBeLessThan(tolerance);
      } else if (dtype === DType.Float64) {
        // Float64 should match very closely
        // Use relative tolerance with small absolute tolerance for near-zero values
        const tolerance = Math.abs(expected) * 1e-10 + 1e-10;
        expect(Math.abs(result - expected)).toBeLessThan(tolerance);
      } else {
        // Integer types should be exact
        expect(result).toBe(expected);
      }
    } finally {
      arr.dispose();
    }
  }
});

describe('Pairwise Summation Accuracy', () => {
  beforeAll(async () => {
    await loadWasmModule();
  });

  it('should be more accurate than naive summation for many small values', async () => {
    // This test demonstrates the advantage of pairwise summation
    // When summing many 0.1 values, naive summation accumulates error

    const n = 10000;
    const value = 0.1;
    const data = Array(n).fill(value);

    const arr = await NDArray.fromArray(data);
    const result = arr.sum();
    arr.dispose();

    // The mathematically correct answer
    const expected = n * value; // 1000.0

    // Pairwise summation should be very close
    // Naive summation would have much larger error
    const relativeError = Math.abs(result - expected) / expected;
    expect(relativeError).toBeLessThan(1e-10);
  });

  it('should handle alternating signs correctly', async () => {
    // Test: 1 - 1 + 1 - 1 + ... (5000 pairs = 0)
    const data: number[] = [];
    for (let i = 0; i < 5000; i++) {
      data.push(1, -1);
    }

    const arr = await NDArray.fromArray(data);
    const result = arr.sum();
    arr.dispose();

    expect(result).toBeCloseTo(0, 10);
  });

  it('should preserve -0.0 in sum of negative zeros', async () => {
    // NumPy's pairwise sum starts with -0.0 to preserve -0 values
    // In JavaScript, -0 === 0 is true, but Object.is(-0, 0) is false
    const arr = await NDArray.zeros([10]);
    const result = arr.sum();
    arr.dispose();

    // The result should be 0 (we don't strictly check for -0 in JS)
    expect(result).toBe(0);
  });
});
